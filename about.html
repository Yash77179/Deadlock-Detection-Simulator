 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>About - Deadlock Detection Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eef2ff',
                            100: '#e0e7ff',
                            200: '#c7d2fe',
                            300: '#a5b4fc',
                            400: '#818cf8',
                            500: '#6366f1',
                            600: '#4f46e5',
                            700: '#4338ca',
                            800: '#3730a3',
                            900: '#312e81',
                        },
                        neutral: {
                            50: '#f9fafb',
                            100: '#f3f4f6',
                            200: '#e5e7eb',
                            300: '#d1d5db',
                            400: '#9ca3af',
                            500: '#6b7280',
                            600: '#4b5563',
                            700: '#374151',
                            800: '#1f2937',
                            900: '#111827',
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        :root {
            --bg-primary: #f9fafb;
            --bg-gradient-1: #eef2ff;
            --bg-gradient-2: #e0e7ff;
            --bg-ripple-1: rgba(224, 231, 255, 0.3);
            --bg-ripple-2: rgba(238, 242, 255, 0.3);
            --bg-ripple-3: rgba(199, 210, 254, 0.3);
            --grid-color: rgba(226, 232, 240, 0.4);
            --card-bg: rgba(255, 255, 255, 0.98);
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-color: rgba(209, 213, 219, 0.5);
            --process-color-1: #4f46e5;
            --process-color-2: #818cf8;
            --resource-color-1: #059669;
            --resource-color-2: #34d399;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --panel-bg: #f3f4f6;
            --input-bg: #ffffff;
            --input-text: #1f2937;
            --input-border: #d1d5db;
            --badge-bg: #e5e7eb;
            --badge-text: #374151;
        }

        [data-theme="dark"] {
            --bg-primary: #121212;
            --bg-gradient-1: #1e1e24;
            --bg-gradient-2: #1a1a2e;
            --bg-ripple-1: rgba(91, 91, 242, 0.05);
            --bg-ripple-2: rgba(30, 30, 46, 0.1);
            --bg-ripple-3: rgba(26, 26, 46, 0.05);
            --grid-color: rgba(75, 85, 99, 0.15);
            --card-bg: rgba(28, 28, 32, 0.98);
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --border-color: rgba(75, 75, 85, 0.5);
            --process-color-1: #5b5bf2;
            --process-color-2: #7b7bf7;
            --resource-color-1: #10b981;
            --resource-color-2: #34d399;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --panel-bg: #202024;
            --input-bg: #2c2c30;
            --input-text: #ffffff;
            --input-border: #444450;
            --badge-bg: #2c2c30;
            --badge-text: #ffffff;
        }
        
        /* High contrast light mode */
        [data-contrast="high"][data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-gradient-1: #ffffff;
            --bg-gradient-2: #ffffff;
            --bg-ripple-1: rgba(224, 231, 255, 0);
            --bg-ripple-2: rgba(238, 242, 255, 0);
            --bg-ripple-3: rgba(199, 210, 254, 0);
            --grid-color: rgba(0, 0, 0, 0.1);
            --card-bg: rgba(255, 255, 255, 1);
            --text-primary: #000000;
            --text-secondary: #000000;
            --border-color: rgba(0, 0, 0, 0.2);
            --process-color-1: #000000;
            --process-color-2: #000000;
            --resource-color-1: #000000;
            --resource-color-2: #000000;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --panel-bg: #ffffff;
            --input-bg: #ffffff;
            --input-text: #000000;
            --input-border: #000000;
            --badge-bg: #ffffff;
            --badge-text: #000000;
        }

        /* High contrast dark mode */
        [data-contrast="high"][data-theme="dark"] {
            --bg-primary: #000000;
            --bg-gradient-1: #000000;
            --bg-gradient-2: #000000;
            --bg-ripple-1: rgba(91, 91, 242, 0);
            --bg-ripple-2: rgba(30, 30, 46, 0);
            --bg-ripple-3: rgba(26, 26, 46, 0);
            --grid-color: rgba(255, 255, 255, 0.1);
            --card-bg: rgba(0, 0, 0, 1);
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --border-color: rgba(255, 255, 255, 0.2);
            --process-color-1: #ffffff;
            --process-color-2: #ffffff;
            --resource-color-1: #ffffff;
            --resource-color-2: #ffffff;
            --shadow-color: rgba(255, 255, 255, 0.1);
            --panel-bg: #000000;
            --input-bg: #000000;
            --input-text: #ffffff;
            --input-border: #ffffff;
            --badge-bg: #000000;
            --badge-text: #ffffff;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            background-image: 
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px),
                radial-gradient(circle at top right, var(--bg-gradient-1), transparent 60%),
                radial-gradient(circle at bottom left, var(--bg-gradient-2), transparent 60%),
                radial-gradient(circle at 30% 20%, var(--bg-ripple-1), transparent 25%),
                radial-gradient(circle at 70% 60%, var(--bg-ripple-2), transparent 30%),
                radial-gradient(circle at 40% 80%, var(--bg-ripple-3), transparent 35%);
            background-size: 25px 25px, 25px 25px, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            background-position: -0.5px -0.5px, -0.5px -0.5px, 0 0, 0 0, 0 0, 0 0, 0 0;
            background-attachment: fixed;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .glass-card {
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 4px 20px var(--shadow-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--card-bg);
            box-shadow: 0 2px 10px var(--shadow-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            color: var(--text-primary);
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        [data-theme="dark"] .dark-icon {
            display: none;
        }

        [data-theme="dark"] .light-icon {
            display: block;
        }

        .dark-icon {
            display: block;
        }

        .light-icon {
            display: none;
        }

        /* Style for the contrast toggle button */
        .contrast-toggle {
            position: fixed;
            top: 20px;
            right: 70px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--card-bg);
            box-shadow: 0 2px 10px var(--shadow-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            color: var(--text-primary) !important;
        }

        .contrast-toggle:hover {
            transform: scale(1.1);
        }
        
        /* Fix contrast toggle icon visibility in all modes */
        .contrast-toggle svg {
            fill: var(--text-primary);
            color: var(--text-primary) !important;
        }
        
        /* Light theme styles */
        [data-theme="light"] .contrast-toggle {
            background-color: white;
            color: black !important;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        [data-theme="light"] .contrast-toggle svg {
            fill: black;
            color: black !important;
        }
        
        /* Dark theme styles */
        [data-theme="dark"] .contrast-toggle {
            background-color: #222;
            color: white !important;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        [data-theme="dark"] .contrast-toggle svg {
            fill: white;
            color: white !important;
        }

        /* High contrast light theme */
        [data-contrast="high"][data-theme="light"] .contrast-toggle {
            background-color: white;
            color: black !important;
            border: 2px solid black;
        }
        
        [data-contrast="high"][data-theme="light"] .contrast-toggle svg {
            fill: black;
            color: black !important;
        }
        
        /* High contrast dark theme */
        [data-contrast="high"][data-theme="dark"] .contrast-toggle {
            background-color: black;
            color: white !important;
            border: 2px solid white;
        }
        
        [data-contrast="high"][data-theme="dark"] .contrast-toggle svg {
            fill: white;
            color: white !important;
        }
        
        /* Ensure header text is white in dark/high contrast mode */
        [data-theme="dark"] h1.text-neutral-800,
        [data-contrast="high"][data-theme="dark"] h1.text-neutral-800 {
            color: var(--text-primary) !important;
        }
        
        /* Ensure active button text is properly visible in all themes */
        [data-contrast="high"][data-theme="dark"] .nav-button.active {
            color: black !important;
        }
        
        [data-contrast="high"][data-theme="light"] .nav-button.active {
            color: white !important;
        }
        
        /* Fix for high contrast mode */
        [data-contrast="high"] .nav-button.active .nav-text {
            color: inherit !important;
        }
        
        [data-contrast="high"] .nav-button.active .nav-icon {
            color: inherit !important;
            fill: currentColor !important;
        }
        
        .text-neutral-800 {
            color: var(--text-primary) !important;
        }
        
        h1.text-neutral-800, 
        h2.text-neutral-800,
        .text-neutral-700, 
        .text-neutral-600 {
            color: var(--text-primary) !important;
        }

        .text-neutral-500 {
            color: var(--text-secondary) !important;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .active-nav {
            background-color: var(--process-color-1);
            color: white;
        }

        
        .concept-card {
            border-left: 4px solid var(--process-color-1);
            padding-left: 16px;
            transition: all 0.3s ease;
        }
        
        .concept-card.resource {
            border-left-color: var(--resource-color-1);
        }
        
        .concept-card.deadlock {
            border-left-color: #ef4444;
        }
        
        /* Interactive elements for About page */
        .expandable-card {
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .expandable-card .expand-icon {
            position: absolute;
            top: 1rem;
            right: 1rem;
            transition: transform 0.3s ease;
        }
        
        .expandable-card.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            opacity: 0;
        }
        
        .expandable-card.expanded .expandable-content {
            max-height: 1000px;
            opacity: 1;
            transition: max-height 0.5s ease, opacity 0.5s ease;
        }
        
        /* Mini deadlock visualizer */
        .mini-visualizer {
            position: relative;
            height: 200px;
            background: var(--panel-bg);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 1rem;
        }
        
        .process-node, .resource-node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s ease;
            cursor: move;
            z-index: 3;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .process-node {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            color: white;
        }
        
        .resource-node {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--resource-color-1), var(--resource-color-2));
            color: white;
        }
        
        /* Fix for high contrast mode */
        [data-contrast="high"] .process-node,
        [data-contrast="high"] .resource-node {
            color: var(--bg-primary) !important;
            font-weight: bold;
        }
        
        [data-contrast="high"][data-theme="dark"] .process-node,
        [data-contrast="high"][data-theme="dark"] .resource-node {
            color: black !important;
        }
        
        [data-contrast="high"][data-theme="light"] .process-node,
        [data-contrast="high"][data-theme="light"] .resource-node {
            color: white !important;
        }
        
        .node-connection {
            position: absolute;
            height: 2px;
            background-color: var(--connection-color);
            transform-origin: left center;
            transition: all 0.3s ease;
            z-index: 1;
        }
        
        .arrow-tip {
            position: absolute;
            right: -7px;
            top: -4px;
            width: 0;
            height: 0;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 8px solid var(--connection-color);
        }
        
        .resource-to-process {
            background-color: var(--resource-color);
        }
        
        .resource-to-process .arrow-tip {
            border-left-color: var(--resource-color);
        }

        .process-to-resource {
            background-color: var(--process-color);
        }
        
        .process-to-resource .arrow-tip {
            border-left-color: var(--process-color);
        }
        
        .highlight-element {
            animation: pulse 1.5s infinite ease-in-out;
        }
        
        /* Interactive definition list */
        .definition-list dt {
            position: relative;
            font-weight: 600;
            cursor: pointer;
            padding-left: 1.5rem;
            margin-bottom: 0.5rem;
            transition: color 0.2s ease;
        }
        
        .definition-list dt::before {
            content: "→";
            position: absolute;
            left: 0;
            transition: transform 0.2s ease;
        }
        
        .definition-list dt:hover {
            color: var(--process-color-1);
        }
        
        .definition-list dt:hover::before {
            transform: translateX(5px);
        }
        
        .definition-list dd {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            padding-left: 1rem;
            border-left: 2px solid var(--border-color);
            opacity: 0.9;
            transition: all 0.2s ease;
        }
        
        .definition-list dt:hover + dd {
            border-left-color: var(--process-color-1);
            opacity: 1;
        }
        
        /* Enhanced Navbar Styling */
        .enhanced-navbar {
            position: relative;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 4px 20px var(--shadow-color);
            padding: 6px;
            margin-top: 1.5rem;
            display: inline-flex;
            transition: all 0.3s ease;
            width: auto;
            justify-content: center;
            gap: 6px;
        }
        
        .nav-item {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 12px 18px;
            border-radius: 12px;
            font-weight: 500;
            font-size: 0.95rem;
            color: var(--text-primary);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            text-align: center;
            min-width: 130px;
        }
        
        .nav-item:before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 2px;
            background: var(--process-color-1);
            transform: translateX(-50%);
            transition: width 0.3s ease;
        }
        
        .nav-item:hover:before {
            width: 80%;
        }
        
        .nav-item:hover {
            background-color: rgba(79, 70, 229, 0.08);
        }
        
        .nav-item.active {
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            color: white;
        }
        
        .nav-item.active:before {
            width: 0;
        }
        
        .nav-item svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
            color: inherit;
        }
        
        /* Fix for high contrast mode to ensure icons match text color */
        [data-contrast="high"] .nav-item svg,
        [data-contrast="high"] .nav-item.active svg {
            fill: currentColor;
        }
        
        [data-contrast="high"][data-theme="dark"] .nav-item.active {
            background: white;
            color: black !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .nav-item.active svg {
            fill: black;
        }
        
        [data-contrast="high"][data-theme="light"] .nav-item.active {
            background: black;
            color: white !important;
        }
        
        @media (max-width: 640px) {
            .enhanced-navbar {
                width: 90%;
                padding: 6px;
            }
            
            .nav-item {
                padding: 8px 12px;
                font-size: 0.85rem;
            }
            
            .nav-item svg {
                width: 16px;
                height: 16px;
            }
        }

        /* New Navbar Styles */
        .navbar-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card-bg);
            border-radius: 50px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            padding: 6px;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
            margin-bottom: 20px;
            transform: translateY(0);
            animation: navAppear 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes navAppear {
            0% { transform: translateY(20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        .navbar-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px -10px rgba(0, 0, 0, 0.15);
        }

        .navbar-track {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50px;
            overflow: hidden;
            z-index: 0;
        }

        .nav-indicator {
            position: absolute;
            top: 6px;
            height: calc(100% - 12px);
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            border-radius: 50px;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1;
            box-shadow: 0 5px 15px -5px var(--process-color-1);
            pointer-events: none;
        }

        .nav-button {
            position: relative;
            padding: 12px 22px;
            border-radius: 50px;
            margin: 0 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-weight: 600;
            transition: all 0.3s ease;
            z-index: 3;
            overflow: hidden;
        }

        .nav-button-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, var(--bg-ripple-1), transparent 70%);
            opacity: 0;
            z-index: -1;
            transform: scale(0.5);
            transition: all 0.4s ease;
        }

        .nav-button:hover .nav-button-background {
            opacity: 0.6;
            transform: scale(1.8);
        }

        .nav-button.active {
            color: white;
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            transition: all 0.3s ease;
        }

        .nav-button:hover:not(.active) .nav-icon {
            transform: translateY(-3px) scale(1.1);
        }

        .nav-button:active:not(.active) .nav-icon {
            transform: translateY(0) scale(0.95);
        }

        .nav-text {
            position: relative;
            transition: all 0.3s ease;
        }

        .nav-button:hover:not(.active) .nav-text {
            transform: translateY(-2px);
        }

        .nav-button:active:not(.active) .nav-text {
            transform: translateY(0) scale(0.95);
        }

        @media (max-width: 768px) {
            .navbar-container {
                width: 95%;
                flex-direction: column;
                border-radius: 20px;
                padding: 8px;
            }

            .nav-button {
                width: 100%;
                margin: 4px 0;
                padding: 10px;
            }

            .nav-indicator {
                display: none;
            }
        }

        /* Add floating particles on hover for navbar */
        .navbar-container::before, 
        .navbar-container::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--process-color-2);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1;
            filter: blur(3px);
        }

        .navbar-container::before {
            top: -5px;
            left: 30%;
        }

        .navbar-container::after {
            bottom: -5px;
            right: 30%;
        }

        .navbar-container:hover::before, 
        .navbar-container:hover::after {
            opacity: 0.7;
            animation: floatParticle 3s infinite alternate;
        }

        @keyframes floatParticle {
            0% { transform: translateY(0) translateX(0); }
            100% { transform: translateY(-10px) translateX(10px); }
        }

        /* 3D Resource Cards Styling */
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .resource-3d-card {
            width: 100%;
            height: 220px;
            perspective: 1000px;
            cursor: pointer;
            transform: translateZ(0); /* Force GPU acceleration */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
            touch-action: manipulation; /* Improve touch behavior */
        }
        
        .resource-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.8s;
            transform-style: preserve-3d;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        /* Apply flip effect on hover for desktop */
        @media (hover: hover) {
            .resource-3d-card:hover .resource-card-inner {
                transform: rotateY(180deg);
            }
        }
        
        /* Handle the flipped state for mobile with a class instead of hover */
        .resource-3d-card.flipped .resource-card-inner {
            transform: rotateY(180deg);
        }
        
        .resource-card-front, .resource-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .resource-card-back {
            transform: rotateY(180deg);
            background: linear-gradient(135deg, var(--panel-bg), var(--card-bg));
            justify-content: space-between;
        }
        
        .resource-icon {
            width: 50px;
            height: 50px;
            margin-bottom: 15px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .resource-3d-card:hover .resource-icon {
            transform: scale(1.1);
        }
        
        .resource-3d-card[data-resource-type="reusable"] .resource-icon {
            color: #4f46e5;
        }
        
        .resource-3d-card[data-resource-type="consumable"] .resource-icon {
            color: #059669;
        }
        
        .resource-3d-card[data-resource-type="preemptable"] .resource-icon {
            color: #d97706;
        }
        
        .resource-3d-card[data-resource-type="non-preemptable"] .resource-icon {
            color: #dc2626;
        }
        
        .resource-3d-card h3 {
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .card-hover-hint {
            font-size: 0.8rem;
            opacity: 0.6;
            position: absolute;
            bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .resource-3d-card:hover .card-hover-hint {
            opacity: 0;
        }
        
        .resource-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .resource-tag {
            background: rgba(79, 70, 229, 0.1);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .resource-3d-card[data-resource-type="reusable"] .resource-tag {
            background: rgba(79, 70, 229, 0.1);
        }
        
        .resource-3d-card[data-resource-type="consumable"] .resource-tag {
            background: rgba(5, 150, 105, 0.1);
        }
        
        .resource-3d-card[data-resource-type="preemptable"] .resource-tag {
            background: rgba(217, 119, 6, 0.1);
        }
        
        .resource-3d-card[data-resource-type="non-preemptable"] .resource-tag {
            background: rgba(220, 38, 38, 0.1);
        }
        
        /* Resource Animation Styling */
        .resource-animation-container {
            margin-top: 30px;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 15px;
            border: 1px solid var(--border-color);
        }
        
        .resource-animation {
            height: 180px;
            position: relative;
            margin-bottom: 15px;
        }
        
        .processes-container {
            position: absolute;
            top: 20px;
            left: 0;
            display: flex;
            gap: 40px;
        }
        
        .resources-container {
            position: absolute;
            bottom: 20px;
            right: 0;
            display: flex;
            gap: 40px;
        }
        
        .process-block, .resource-block {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 15px;
            border-radius: 12px;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .process-block {
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            color: white;
            min-width: 50px;
            height: 50px;
        }
        
        .resource-block {
            background: linear-gradient(135deg, var(--resource-color-1), var(--resource-color-2));
            color: white;
            min-width: 80px;
            flex-direction: column;
            gap: 5px;
            position: relative;
        }
        
        .resource-units {
            display: flex;
            gap: 5px;
        }
        
        .resource-unit {
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .resource-unit.allocated {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .resource-label {
            font-size: 0.8rem;
            position: absolute;
            bottom: -20px;
            color: var(--text-primary);
        }
        
        .allocation-arrow {
            position: absolute;
            height: 2px;
            background-color: var(--process-color-1);
            transform-origin: left center;
            z-index: 1;
            transition: all 0.5s ease;
        }
        
        .allocation-arrow::after {
            content: '';
            position: absolute;
            right: -4px;
            top: -3px;
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-left: 6px solid var(--process-color-1);
        }
        
        .request-arrow {
            background-color: #ababab;
            height: 1px;
            opacity: 0.7;
        }
        
        .request-arrow::after {
            border-left-color: #ababab;
        }
        
        .allocation-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .allocate-btn {
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .allocate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .allocate-btn:active {
            transform: translateY(0);
        }
        
        .allocation-message {
            font-size: 0.9rem;
            min-height: 20px;
            text-align: center;
            color: var(--text-secondary);
        }
        
        /* Animation for resource cards */
        @keyframes cardFloat {
            0% { transform: translateY(0) rotate(0); }
            50% { transform: translateY(-10px) rotate(1deg); }
            100% { transform: translateY(0) rotate(0); }
        }
        
        @keyframes glowPulse {
            0% { box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
            50% { box-shadow: 0 5px 30px rgba(79, 70, 229, 0.2); }
            100% { box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        }
        
        /* Add responsive adjustments */
        @media (max-width: 768px) {
            .resource-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            /* Fix for mobile resource cards to prevent layout shifts */
            .resource-3d-card {
                transform: none !important;
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
                will-change: transform, opacity;
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
                transform-style: flat !important;
                position: relative !important;
                z-index: 1;
                perspective: none !important;
                height: 220px;
            }
            
            /* Improved content positioning for better appearance */
            .resource-3d-card .resource-card-front,
            .resource-3d-card .resource-card-back {
                padding: 16px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                text-align: center;
                box-sizing: border-box;
                width: 100%;
                height: 100%;
            }
            
            .resource-3d-card .resource-icon {
                width: 40px;
                height: 40px;
                margin-bottom: 10px;
                margin-top: 10px;
            }
            
            .resource-3d-card h3 {
                font-size: 1rem;
                margin: 0 0 8px 0;
                padding: 0;
                line-height: 1.3;
                font-weight: 600;
            }
            
            .resource-3d-card .card-hover-hint {
                position: absolute;
                bottom: 12px;
                left: 0;
                right: 0;
                text-align: center;
                font-size: 0.7rem;
                opacity: 0.7;
            }
            
            .resource-3d-card .resource-card-back p {
                font-size: 0.85rem;
                line-height: 1.4;
                margin: 0 0 12px 0;
                padding: 0;
                max-width: 90%;
            }
            
            .resource-3d-card .resource-examples {
                margin-top: 15px;
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                justify-content: center;
                width: 100%;
            }
            
            .resource-3d-card .resource-tag {
                font-size: 0.7rem;
                padding: 3px 8px;
                border-radius: 10px;
            }
            
            .resource-card-inner {
                transition: none !important;
                transform: none !important;
                transform-style: flat !important;
                backface-visibility: visible !important;
                -webkit-backface-visibility: visible !important;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1) !important;
            }
            
            .resource-card-front, .resource-card-back {
                position: absolute;
                backface-visibility: visible !important;
                -webkit-backface-visibility: visible !important;
            }
            
            .resource-card-back {
                opacity: 0;
                transform: none !important;
                z-index: -1;
            }
            
            /* Handle mobile taps with opacity instead of 3D transforms */
            .resource-3d-card.flipped .resource-card-front {
                opacity: 0;
                z-index: -1;
            }
            
            .resource-3d-card.flipped .resource-card-back {
                opacity: 1;
                z-index: 2;
                transform: none !important;
            }
            
            /* Prevent position shifts */
            .theme-toggle, 
            .contrast-toggle {
                position: fixed !important;
                transform: none !important;
            }
            
            /* Ensure content doesn't shift when cards are tapped */
            .resource-3d-card * {
                transform: none !important;
                transition: opacity 0.3s ease !important;
            }
        }
        
        @media (max-width: 480px) {
            .resource-grid {
                grid-template-columns: 1fr;
            }
            
            .process-block, .resource-block {
                min-width: 40px;
                height: 40px;
                font-size: 0.9rem;
            }
        }

        /* Animation for resource cards */
        @keyframes cardFloat {
            0% { transform: translateY(0) rotate(0); }
            50% { transform: translateY(-10px) rotate(1deg); }
            100% { transform: translateY(0) rotate(0); }
        }
        
        @keyframes glowPulse {
            0% { box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
            50% { box-shadow: 0 5px 30px rgba(79, 70, 229, 0.2); }
            100% { box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        }
        
        /* Process State Diagram and Visualization Styles */
        .process-interactive-container {
            margin-top: 10px;
        }
        
        .process-state-diagram {
            position: relative;
            background: var(--panel-bg);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        .process-states {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
            position: relative;
            z-index: 2;
        }
        
        .process-state {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            width: 110px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        
        .process-state:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        }
        
        .process-state.active {
            box-shadow: 0 0 0 2px var(--process-color-1), 0 8px 15px rgba(0,0,0,0.1);
        }
        
        .state-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 10px;
            color: var(--text-primary);
            opacity: 0.8;
            transition: all 0.3s ease;
        }
        
        .process-state:hover .state-icon {
            transform: scale(1.1);
            opacity: 1;
        }
        
        .process-state[data-state="new"] .state-icon {
            color: #4f46e5;
        }
        
        .process-state[data-state="ready"] .state-icon {
            color: #f59e0b;
        }
        
        .process-state[data-state="running"] .state-icon {
            color: #10b981;
        }
        
        .process-state[data-state="blocked"] .state-icon {
            color: #ef4444;
        }
        
        .process-state[data-state="terminated"] .state-icon {
            color: #6b7280;
        }
        
        .state-label {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 5px;
        }
        
        .state-description {
            font-size: 0.7rem;
            text-align: center;
            color: var(--text-secondary);
            line-height: 1.2;
        }
        
        .state-transitions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .transition-arrow {
            position: absolute;
            height: 2px;
            background-color: var(--text-secondary);
            transform-origin: left center;
            z-index: 1;
            opacity: 0.5;
            transition: all 0.3s ease;
        }
        
        .transition-arrow::after {
            content: '';
            position: absolute;
            right: -6px;
            top: -3px;
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-left: 6px solid var(--text-secondary);
        }
        
        .transition-arrow.highlight {
            background-color: var(--process-color-1);
            opacity: 1;
            height: 3px;
        }
        
        .transition-arrow.highlight::after {
            border-left-color: var(--process-color-1);
        }
        
        /* Process Simulator */
        .process-simulator {
            background: var(--panel-bg);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }
        
        .process-container {
            position: relative;
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 150px;
            margin-bottom: 20px;
        }
        
        .cpu-block {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #4f46e5, #818cf8);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
            position: relative;
            animation: pulse 2s infinite ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .cpu-core {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        
        .process-queue {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .queue-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        .queue-slots {
            display: flex;
            gap: 10px;
        }
        
        .process-slot {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px dashed var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            transition: all 0.3s ease;
            background: var(--card-bg);
        }
        
        .process-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .process-circle:hover {
            transform: scale(1.1);
        }
        
        .process-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .process-btn {
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 0.85rem;
        }
        
        .process-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .process-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        
        .process-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .process-message {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
            height: 20px;
        }
        
        .process-stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--card-bg);
            padding: 8px 15px;
            border-radius: 8px;
            min-width: 70px;
            border: 1px solid var(--border-color);
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        /* Animation for the flying process */
        @keyframes flyProcess {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--fly-x), var(--fly-y)) scale(0.7); opacity: 0.9; }
        }
        
        .flying-process {
            position: absolute;
            z-index: 10;
            --fly-x: 0px;
            --fly-y: 0px;
            animation: flyProcess 0.5s forwards ease-out;
        }
        
        /* Add responsive adjustments */
        @media (max-width: 768px) {
            .process-states {
                justify-content: center;
            }
            
            .process-container {
                flex-direction: column;
                height: auto;
                gap: 20px;
            }
            
            .process-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .process-btn {
                width: 100%;
                max-width: 200px;
            }
        }
        
        @media (max-width: 480px) {
            .resource-grid {
                grid-template-columns: 1fr;
            }
            
            .process-block, .resource-block {
                min-width: 40px;
                height: 40px;
                font-size: 0.9rem;
            }
        }

        /* Animation for the flying process */
        @keyframes flyProcess {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--fly-x), var(--fly-y)) scale(0.7); opacity: 0.9; }
        }
        
        .flying-process {
            position: absolute;
            z-index: 10;
            --fly-x: 0px;
            --fly-y: 0px;
            animation: flyProcess 0.5s forwards ease-out;
        }
        
        /* Resource Allocation Graph Interactive Styles */
        .rag-interactive {
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 4px 20px var(--shadow-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            padding: 20px;
            margin-top: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .rag-canvas-container {
            height: 500px;
            position: relative;
            display: flex;
            flex-direction: column;
            border-radius: 12px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 2px 10px var(--shadow-color);
        }
        
        .rag-controls {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .rag-control-group {
            display: flex;
            gap: 8px;
        }
        
        .rag-btn {
            padding: 6px 12px;
            border-radius: 6px;
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            color: white;
            font-size: 0.85rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
        }
        
        .rag-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .rag-btn:active {
            transform: translateY(0);
        }
        
        .rag-btn.warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .rag-btn.danger {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
        }
        
        .rag-workspace {
            display: flex;
            flex-grow: 1;
            position: relative;
        }
        
        .rag-canvas {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0;
            transition: all 0.3s ease;
            min-height: 350px;
        }
        
        .rag-node {
            position: absolute;
            cursor: move;
            user-select: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            z-index: 2;
        }
        
        .rag-node:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .rag-node.selected {
            box-shadow: 0 0 0 2px var(--primary-500), 0 0 15px rgba(99, 102, 241, 0.5);
            transform: scale(1.05);
        }
        
        .rag-process {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .rag-resource {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--resource-color-1), var(--resource-color-2));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .rag-edge {
            position: absolute;
            height: 2px;
            background-color: #666;
            transform-origin: 0 0;
            z-index: 1;
            pointer-events: none;
            transition: background-color 0.3s ease;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.05);
        }
        
        .rag-edge::after {
            content: '';
            position: absolute;
            right: -6px;
            top: -3px;
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-left: 6px solid currentColor;
            color: inherit;
        }
        
        .rag-edge.allocation {
            background-color: var(--resource-color-1);
        }
        
        .rag-edge.allocation::after {
            border-left-color: var(--resource-color-1);
        }
        
        .rag-edge.request {
            background-color: var(--process-color-1);
            border-top: 2px dashed var(--process-color-1);
            height: 0px;
        }
        
        .rag-edge.request::after {
            border-left-color: var(--process-color-1);
        }
        
        .rag-edge.deadlock {
            background-color: #ef4444;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.4);
            animation: pulse 1.5s infinite;
        }
        
        .rag-edge.deadlock::after {
            border-left-color: #ef4444;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .rag-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 5;
            min-width: 120px;
        }
        
        /* Specific dark theme enhancements for the legend */
        [data-theme="dark"] .rag-legend {
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(99, 102, 241, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        /* High contrast mode for the legend */
        [data-contrast="high"] .rag-legend {
            background: #ffffff;
            border: 2px solid #000000;
            box-shadow: none;
        }
        
        [data-contrast="high"][data-theme="dark"] .rag-legend {
            background: #000000;
            border: 2px solid #ffffff;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .legend-color.process-color {
            background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
        }
        
        .legend-color.resource-color {
            background: linear-gradient(135deg, var(--resource-color-1), var(--resource-color-2));
        }
        
        .legend-label {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .legend-arrow {
            position: relative;
            height: 2px;
            width: 40px;
            margin: 0 5px;
        }
        
        .legend-arrow::after {
            content: '';
            position: absolute;
            right: -1px;
            top: -4px;
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-left: 8px solid currentColor;
        }
        
        .legend-arrow.allocation-arrow {
            background-color: var(--resource-color-1);
        }
        
        .legend-arrow.allocation-arrow::after {
            border-left-color: var(--resource-color-1);
        }
        
        .legend-arrow.request-arrow {
            background-color: transparent;
            height: 0;
            border-top: none;
        }
        
        .legend-arrow.request-arrow::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 0;
            border-top: 2px dashed var(--process-color-1);
        }
        
        .legend-arrow.request-arrow::after {
            border-left-color: var(--process-color-1);
        }
        
        /* Dark mode adjustments for legend */
        [data-theme="dark"] .legend-arrow.allocation-arrow {
            background-color: var(--resource-color-2);
        }
        
        [data-theme="dark"] .legend-arrow.allocation-arrow::after {
            border-left-color: var(--resource-color-2);
        }
        
        [data-theme="dark"] .legend-arrow.request-arrow {
            border-top: 2px dashed var(--process-color-2);
        }
        
        [data-theme="dark"] .legend-arrow.request-arrow::after {
            border-left-color: var(--process-color-2);
        }
        
        /* High contrast mode for legend */
        [data-contrast="high"] .legend-arrow.allocation-arrow,
        [data-contrast="high"] .legend-arrow.request-arrow {
            background-color: #000000;
        }
        
        [data-contrast="high"] .legend-arrow.request-arrow {
            border-top: 2px dashed #000000;
        }
        
        [data-contrast="high"] .legend-arrow::after {
            border-left-color: #000000;
        }
        
        [data-contrast="high"][data-theme="dark"] .legend-arrow.allocation-arrow,
        [data-contrast="high"][data-theme="dark"] .legend-arrow.request-arrow {
            background-color: #ffffff;
        }
        
        [data-contrast="high"][data-theme="dark"] .legend-arrow.request-arrow {
            border-top: 2px dashed #ffffff;
        }
        
        [data-contrast="high"][data-theme="dark"] .legend-arrow::after {
            border-left-color: #ffffff;
        }
        
        .rag-message {
            padding: 12px;
            text-align: center;
            border-top: 1px solid var(--border-color);
            background: var(--panel-bg);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        
        .tooltip-heading {
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--text-primary);
        }
        
        .tooltip-list {
            padding-left: 20px;
            color: var(--text-secondary);
        }
        
        .tooltip-list li {
            margin-bottom: 4px;
        }
        
        /* Add responsive adjustments */
        @media (max-width: 768px) {
            .rag-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .rag-control-group {
                flex-direction: column;
                gap: 10px;
            }
            
            .rag-btn {
                width: 100%;
                max-width: 200px;
            }
        }

        .tutorial-glow {
            text-shadow: 0 0 15px rgba(var(--primary-rgb), 0.3);
            position: relative;
            display: inline-block;
            padding: 0.25em 0.5em;
            border-radius: 0.25em;
            background: linear-gradient(135deg, rgba(var(--primary-rgb), 0.1), transparent 70%);
        }
        
        [data-theme="dark"] .tutorial-glow {
            text-shadow: 0 0 20px rgba(var(--primary-rgb), 0.4);
            background: linear-gradient(135deg, rgba(var(--primary-rgb), 0.15), transparent 80%);
        }
        
        [data-contrast="high"] .tutorial-glow {
            background-color: var(--primary-600);
            color: white !important;
            text-shadow: none;
            border: 2px solid black !important;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5) !important;
        }
        
        /* Fix process buttons in high contrast mode */
        [data-contrast="high"] .process-btn {
            background: black !important;
            color: white !important;
            border: 2px solid white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .process-btn {
            background: white !important;
            color: black !important;
            border: 2px solid black !important;
        }
        
        /* Fix process elements in high contrast mode */
        [data-contrast="high"] .process-slot,
        [data-contrast="high"] .process-bubble,
        [data-contrast="high"] .process-block {
            background: black !important;
            color: white !important;
            border: 2px solid white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .process-slot,
        [data-contrast="high"][data-theme="dark"] .process-bubble,
        [data-contrast="high"][data-theme="dark"] .process-block {
            background: white !important;
            color: black !important;
            border: 2px solid black !important;
        }
        
        /* Fix SVG icons in process buttons in high contrast mode */
        [data-contrast="high"] .process-btn svg,
        [data-contrast="high"] .process-element svg {
            fill: white !important;
            color: white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .process-btn svg,
        [data-contrast="high"][data-theme="dark"] .process-element svg {
            fill: black !important;
            color: black !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .process-btn svg,
        [data-contrast="high"][data-theme="dark"] .process-element svg {
            fill: black !important;
            color: black !important;
        }
        
        /* Fix Resource Allocation Graph elements in high contrast mode */
        [data-contrast="high"] .rag-node {
            background: black !important;
            color: white !important;
            border: 2px solid white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .rag-node {
            background: white !important;
            color: black !important;
            border: 2px solid black !important;
        }
        
        /* Fix graph edges in high contrast mode */
        [data-contrast="high"] .rag-edge {
            background-color: white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .rag-edge {
            background-color: black !important;
        }
        
        /* Fix edge arrows in high contrast mode */
        [data-contrast="high"] .rag-edge.request::after {
            border-left-color: white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .rag-edge.request::after {
            border-left-color: black !important;
        }
        
        /* Fix edge arrows in high contrast mode */
        [data-contrast="high"] .rag-edge.request::after {
            border-left-color: white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .rag-edge.request::after {
            border-left-color: black !important;
        }
        
        /* Fix Simulate Allocation button in high contrast mode */
        [data-contrast="high"] .allocate-btn {
            background: black !important;
            color: white !important;
            border: 2px solid white !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .allocate-btn {
            background: white !important;
            color: black !important;
            border: 2px solid black !important;
        }
        
        [data-contrast="high"][data-theme="dark"] .try-simulator-btn {
            color: black !important;
            background-color: white !important;
        }
        
        /* Fix Master the Simulator title in high contrast mode */
        [data-contrast="high"] h2.tutorial-glow {
            background-color: transparent !important;
            color: black !important;
            text-shadow: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            border-radius: 0 !important;
        }
        
        [data-contrast="high"][data-theme="dark"] h2.tutorial-glow {
            background-color: transparent !important;
            color: white !important;
            text-shadow: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            border-radius: 0 !important;
        }

        /* Specific mobile enhancements to prevent unwanted shifting */
        @media (max-width: 768px) {
            .resource-3d-card {
                transform: none !important;
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
                will-change: transform;
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
                transition: none !important;
            }
            
            .resource-3d-card:active {
                transform: none !important;
            }
            
            /* Make particles smaller and less disruptive on mobile */
            .resource-3d-card .particle {
                width: 4px !important;
                height: 4px !important;
                opacity: 0.5 !important;
            }
        }
        
        /* High contrast mode adjustments */
        [data-contrast="high"] .neural-network-bg {
            background: var(--bg-primary);
        }
        
        /* Mobile optimizations */
        .mobile-device {
            /* Disable all animations that might cause layout shifts */
            --disable-transform: none !important;
            --disable-animation: none !important;
            --disable-transition: none !important;
        }
        
        .mobile-device * {
            animation-duration: 0s !important;
            transition-duration: 0s !important;
        }
        
        .mobile-device .resource-3d-card,
        .mobile-device .glass-card,
        .mobile-device .flying-process,
        .mobile-device .process-circle {
            transform: none !important;
            transition: none !important;
            animation: none !important;
            position: relative !important;
        }
        
        /* Fixed positioning for particles on mobile */
        .mobile-device .particle {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 4px !important;
            height: 4px !important;
            opacity: 0.5 !important;
            transform: none !important;
            animation: none !important;
            overflow: hidden !important;
            margin: 0 !important;
            transition: none !important;
        }
        
        /* Special fix for reusable resource card */
        .mobile-device .resource-3d-card[data-resource-type="reusable"] {
            position: relative !important;
            overflow: hidden !important;
        }
        
        .mobile-device .resource-3d-card[data-resource-type="reusable"] .resource-card-inner {
            transform: none !important;
            transition: none !important;
            position: relative !important;
        }
        
        .mobile-device .resource-3d-card[data-resource-type="reusable"] .resource-card-front,
        .mobile-device .resource-3d-card[data-resource-type="reusable"] .resource-card-back {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
        }
        
        .mobile-device .resource-3d-card[data-resource-type="reusable"].flipped .resource-card-front {
            opacity: 0 !important;
            z-index: -1 !important;
        }
        
        .mobile-device .resource-3d-card[data-resource-type="reusable"].flipped .resource-card-back {
            opacity: 1 !important;
            z-index: 2 !important;
            transform: none !important;
        }
        
        /* Optimize rendering performance for touch devices */
        .mobile-device * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* Change hint text based on device capabilities */
        @media (hover: none) {
            .card-hover-hint {
                content: "Tap for details" !important;
            }
        }
        
        /* Fix for reusable resource card to match other cards */
        .mobile-device .resource-3d-card[data-resource-type="reusable"] {
            position: relative !important;
            overflow: hidden !important;
        }
        
        /* Change card hint text based on device */
        @media (hover: none), (pointer: coarse) {
            .card-hover-hint::before {
                content: "Tap for details";
                display: block;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: inherit;
            }
            
            .card-hover-hint {
                color: transparent !important;
                position: relative;
            }
        }

        /* Better positioning for theme and contrast toggles on mobile */
        @media (max-width: 768px) {
            .theme-toggle,
            .contrast-toggle {
                position: fixed !important;
                z-index: 1000 !important;
                transform: none !important;
                top: auto !important;
                bottom: 20px !important;
            }
            
            .theme-toggle {
                right: 20px !important;
            }
            
            .contrast-toggle {
                right: 70px !important;
            }
            
            /* Add some space at the bottom of the page to account for the fixed icons */
            body {
                padding-bottom: 70px !important;
            }
        }
    </style>
</head>
<body class="min-h-screen py-8 px-4 sm:px-6 md:px-8">
    <!-- Theme Toggle Button -->
    <div class="theme-toggle" id="themeToggle">
        <!-- Sun icon for light mode -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 dark-icon" viewBox="0 0 20 20" fill="currentColor">
            <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" />
        </svg>
        <!-- Moon icon for dark mode -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 light-icon" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd" />
        </svg>
    </div>

    <!-- Add a high contrast toggle button -->
    <div class="contrast-toggle" id="contrastToggle" title="Toggle high contrast mode">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 2a6 6 0 110 12 6 6 0 010-12z" clip-rule="evenodd" />
            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
        </svg>
    </div>

    <div class="max-w-5xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-neutral-800 mb-2">About the Deadlock Detection Simulator</h1>
            <p class="text-neutral-500 max-w-2xl mx-auto">Understanding deadlocks, resource allocation, and detection algorithms</p>
            
            <!-- Navigation Bar -->
            <div class="flex justify-center mt-8 w-full">
                <nav class="navbar-container">
                    <div class="navbar-track"></div>
                    <div class="nav-indicator"></div>
                    <a href="index.html" class="nav-button" data-page="simulator">
                        <div class="nav-button-background"></div>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="nav-icon">
                            <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                        </svg>
                        <span class="nav-text">Simulator</span>
                    </a>
                    <a href="about.html" class="nav-button active" data-page="about">
                        <div class="nav-button-background"></div>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="nav-icon">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                        </svg>
                        <span class="nav-text">About</span>
                    </a>
                    <a href="team.html" class="nav-button" data-page="team">
                        <div class="nav-button-background"></div>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="nav-icon">
                            <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z" />
                        </svg>
                        <span class="nav-text">Team</span>
                    </a>
                </nav>
            </div>
        </header>
        
        <main class="space-y-8">
            <section class="glass-card p-8">
                <h2 class="text-2xl font-bold mb-4">What is a Deadlock?</h2>
                <p class="mb-6">A deadlock is a situation in operating systems where two or more processes are unable to proceed because each is waiting for resources held by another process. This creates a circular wait condition where no process can continue.</p>
                
                <div class="expandable-card concept-card deadlock p-4 bg-opacity-10 bg-red-100 rounded-lg mb-6">
                    <h3 class="font-semibold mb-2">The Four Conditions for Deadlock</h3>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 expand-icon" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    <div class="expandable-content">
                        <ol class="list-decimal pl-6 space-y-2 mt-3">
                            <li><strong>Mutual Exclusion:</strong> Resources cannot be shared simultaneously.</li>
                            <li><strong>Hold and Wait:</strong> Processes hold resources while waiting for others.</li>
                            <li><strong>No Preemption:</strong> Resources cannot be forcibly taken away.</li>
                            <li><strong>Circular Wait:</strong> A closed chain of processes exists, each waiting for a resource held by the next.</li>
                        </ol>
                    </div>
                </div>
                
                <p class="mt-5">Understanding these four conditions is crucial for developing strategies to prevent and detect deadlocks in operating systems.</p>
            </section>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <section class="glass-card p-6">
                    <h2 class="text-xl font-bold mb-4 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-primary-600" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12z" clip-rule="evenodd" />
                        </svg>
                        Processes in Operating Systems
                    </h2>
                    <div class="process-interactive-container">
                        <p class="mb-4">A process is an instance of a program in execution. Each process needs various resources to function, like CPU time, memory, files, and I/O devices.</p>
                        
                        <div class="process-state-diagram">
                            <div class="process-states">
                                <div class="process-state" data-state="new">
                                    <div class="state-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M12 5v14M5 12h14"></path>
                                        </svg>
                                    </div>
                                    <div class="state-label">New</div>
                                    <div class="state-description">Process is being created</div>
                                </div>
                                <div class="process-state" data-state="ready">
                                    <div class="state-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <circle cx="12" cy="12" r="10"></circle>
                                            <polyline points="12 6 12 12 16 14"></polyline>
                                        </svg>
                                    </div>
                                    <div class="state-label">Ready</div>
                                    <div class="state-description">Waiting to be assigned to CPU</div>
                                </div>
                                <div class="process-state" data-state="running">
                                    <div class="state-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M5 3v4M3 5h4M6 17v4M4 19h4M17 3v4M19 5h-4M6 9v4M8 11H4"></path>
                                            <circle cx="17" cy="12" r="3"></circle>
                                            <path d="M19.2 17.8L22 20M17 9.2L14 6.8M17 14.8L14 17.2M19.2 6.2L22 4"></path>
                                        </svg>
                                    </div>
                                    <div class="state-label">Running</div>
                                    <div class="state-description">Executing instructions</div>
                                </div>
                                <div class="process-state" data-state="blocked">
                                    <div class="state-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                            <line x1="9" y1="3" x2="9" y2="21"></line>
                                        </svg>
                                    </div>
                                    <div class="state-label">Blocked</div>
                                    <div class="state-description">Waiting for resources</div>
                                </div>
                                <div class="process-state" data-state="terminated">
                                    <div class="state-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M18 6L6 18M6 6l12 12"></path>
                                        </svg>
                                    </div>
                                    <div class="state-label">Terminated</div>
                                    <div class="state-description">Execution completed</div>
                                </div>
                            </div>
                            
                            <div class="state-transitions">
                                <!-- Transition arrows will be drawn by JS -->
                            </div>
                        </div>
                        
                        <div class="process-simulator">
                            <div class="process-container">
                                <div class="cpu-block">
                                    <div class="cpu-core">CPU</div>
                                </div>
                                
                                <div class="process-queue ready-queue">
                                    <div class="queue-label">Ready Queue</div>
                                    <div class="queue-slots">
                                        <div class="process-slot ready-slot" id="ready1"></div>
                                        <div class="process-slot ready-slot" id="ready2"></div>
                                        <div class="process-slot ready-slot" id="ready3"></div>
                                    </div>
                                </div>
                                
                                <div class="process-queue blocked-queue">
                                    <div class="queue-label">Blocked Queue</div>
                                    <div class="queue-slots">
                                        <div class="process-slot blocked-slot" id="blocked1"></div>
                                        <div class="process-slot blocked-slot" id="blocked2"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="process-controls">
                                <button class="process-btn" id="createProcessBtn">Create Process</button>
                                <button class="process-btn" id="blockProcessBtn">Block Process</button>
                                <button class="process-btn" id="unblockProcessBtn">Unblock Process</button>
                                <button class="process-btn" id="terminateProcessBtn">Terminate Process</button>
                            </div>
                            
                            <div class="process-info">
                                <div class="process-message" id="processMessage">Click "Create Process" to start</div>
                                <div class="process-stats">
                                    <div class="stat-box">
                                        <div class="stat-label">Created</div>
                                        <div class="stat-value" id="createdCount">0</div>
                                    </div>
                                    <div class="stat-box">
                                        <div class="stat-label">Running</div>
                                        <div class="stat-value" id="runningCount">0</div>
                                    </div>
                                    <div class="stat-box">
                                        <div class="stat-label">Blocked</div>
                                        <div class="stat-value" id="blockedCount">0</div>
                                    </div>
                                    <div class="stat-box">
                                        <div class="stat-label">Terminated</div>
                                        <div class="stat-value" id="terminatedCount">0</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                
                <section class="glass-card p-6">
                    <h2 class="text-xl font-bold mb-4 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-emerald-600" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM14 11a1 1 0 011 1v1h1a1 1 0 110 2h-1v1a1 1 0 11-2 0v-1h-1a1 1 0 110-2h1v-1a1 1 0 011-1z" />
                        </svg>
                        Resources and Allocation
                    </h2>
                    
                    <div class="resource-cards">
                        <p class="mb-4">Resources are anything a process needs to execute. They can have multiple instances (units) and different properties:</p>
                        
                        <div class="resource-grid">
                            <!-- Resource Card 1 - Reusable -->
                            <div class="resource-3d-card" data-resource-type="reusable">
                                <div class="resource-card-inner">
                                    <div class="resource-card-front">
                                        <div class="resource-icon">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                                                <line x1="8" y1="21" x2="16" y2="21"></line>
                                                <line x1="12" y1="17" x2="12" y2="21"></line>
                                            </svg>
                                        </div>
                                        <h3>Reusable Resources</h3>
                                        <div class="card-hover-hint">Hover for details</div>
                                    </div>
                                    <div class="resource-card-back">
                                        <p>Can be used by one process at a time and then released for use by other processes.</p>
                                        <div class="resource-examples">
                                            <span class="resource-tag">CPU</span>
                                            <span class="resource-tag">I/O Channels</span>
                                            <span class="resource-tag">Memory</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Resource Card 2 - Consumable -->
                            <div class="resource-3d-card" data-resource-type="consumable">
                                <div class="resource-card-inner">
                                    <div class="resource-card-front">
                                        <div class="resource-icon">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="10"></circle>
                                                <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                                                <line x1="9" y1="9" x2="9.01" y2="9"></line>
                                                <line x1="15" y1="9" x2="15.01" y2="9"></line>
                                            </svg>
                                        </div>
                                        <h3>Consumable Resources</h3>
                                        <div class="card-hover-hint">Hover for details</div>
                                    </div>
                                    <div class="resource-card-back">
                                        <p>Can be created and destroyed during system operation.</p>
                                        <div class="resource-examples">
                                            <span class="resource-tag">Interrupts</span>
                                            <span class="resource-tag">Signals</span>
                                            <span class="resource-tag">Messages</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Resource Card 3 - Preemptable -->
                            <div class="resource-3d-card" data-resource-type="preemptable">
                                <div class="resource-card-inner">
                                    <div class="resource-card-front">
                                        <div class="resource-icon">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <polyline points="23 4 23 10 17 10"></polyline>
                                                <polyline points="1 20 1 14 7 14"></polyline>
                                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                                            </svg>
                                        </div>
                                        <h3>Preemptable Resources</h3>
                                        <div class="card-hover-hint">Hover for details</div>
                                    </div>
                                    <div class="resource-card-back">
                                        <p>Can be taken away from a process without causing failure.</p>
                                        <div class="resource-examples">
                                            <span class="resource-tag">CPU Time</span>
                                            <span class="resource-tag">Memory</span>
                                            <span class="resource-tag">Cache</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Resource Card 4 - Non-preemptable -->
                            <div class="resource-3d-card" data-resource-type="non-preemptable">
                                <div class="resource-card-inner">
                                    <div class="resource-card-front">
                                        <div class="resource-icon">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                            </svg>
                                        </div>
                                        <h3>Non-preemptable Resources</h3>
                                        <div class="card-hover-hint">Hover for details</div>
                                    </div>
                                    <div class="resource-card-back">
                                        <p>Cannot be taken away without potentially causing failure.</p>
                                        <div class="resource-examples">
                                            <span class="resource-tag">Printers</span>
                                            <span class="resource-tag">Disk Drives</span>
                                            <span class="resource-tag">DVD Burners</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="resource-animation-container mt-6">
                            <div class="resource-animation">
                                <div class="processes-container">
                                    <div class="process-block" id="process1">P1</div>
                                    <div class="process-block" id="process2">P2</div>
                                </div>
                                <div class="resources-container">
                                    <div class="resource-block" id="resource1">
                                        <div class="resource-units">
                                            <div class="resource-unit"></div>
                                            <div class="resource-unit"></div>
                                        </div>
                                        <div class="resource-label">R1</div>
                                    </div>
                                    <div class="resource-block" id="resource2">
                                        <div class="resource-units">
                                            <div class="resource-unit"></div>
                                            <div class="resource-unit"></div>
                                            <div class="resource-unit"></div>
                                        </div>
                                        <div class="resource-label">R2</div>
                                    </div>
                                </div>
                                <div class="allocation-arrows">
                                    <!-- Arrows will be added by JavaScript -->
                                </div>
                            </div>
                            <div class="allocation-controls">
                                <button class="allocate-btn" id="allocateBtn">Simulate Allocation</button>
                                <div class="allocation-message" id="allocationMessage"></div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
            
            
            <section class="glass-card p-0 overflow-hidden">
                <div class="relative">
                    <!-- Background Animation Canvas -->
                    <canvas id="tutorialCanvas" class="absolute top-0 left-0 w-full h-full opacity-30"></canvas>
                    
                    <!-- Header with glowing effect -->
                    <div class="relative p-8 pb-4 text-center">
                        <h2 class="text-3xl font-bold mb-2 tutorial-glow">Master the Simulator</h2>
                        <div class="w-20 h-1 bg-gradient-to-r from-primary-400 to-primary-600 mx-auto rounded-full mb-6"></div>
                        <p class="text-lg text-center max-w-2xl mx-auto">Follow this interactive guide to become a deadlock detection expert!</p>
                    </div>
                    
                    <!-- Interactive Tutorial Steps -->
                    <div class="tutorial-steps p-6">
                        <!-- Progress Bar -->
                        <div class="tutorial-progress mb-8">
                            <div class="flex justify-between mb-2">
                                <span class="text-sm font-medium">Beginner</span>
                                <span class="text-sm font-medium">Expert</span>
                            </div>
                            <div class="h-2 bg-gray-200 rounded-full overflow-hidden dark:bg-gray-700">
                                <div class="tutorial-progress-bar h-full bg-gradient-to-r from-primary-500 to-primary-400 rounded-full transition-all duration-1000" style="width: 25%"></div>
                            </div>
                        </div>
                        
                        <!-- Tutorial Cards -->
                        <div class="tutorial-cards space-y-6">
                            <!-- Step 1 -->
                            <div class="tutorial-card active" data-step="1">
                                <div class="flex items-start md:items-center flex-col md:flex-row p-6 rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1 cursor-pointer tutorial-card-content">
                                    <div class="tutorial-step-number flex-shrink-0 w-12 h-12 rounded-full flex items-center justify-center text-white font-bold mb-4 md:mb-0 md:mr-6 bg-gradient-to-br from-primary-400 to-primary-600" style="color: white !important; background: linear-gradient(135deg, #3b82f6, #2563eb) !important;">1</div>
                                    <div class="tutorial-content flex-grow">
                                        <h3 class="font-bold text-xl mb-2 flex items-center">
                                            Create Your System Components
                                            <span class="ml-2 tutorial-badge px-2 py-1 text-xs rounded-full bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100">Essential</span>
                                        </h3>
                                        <div class="tutorial-details">
                                            <p class="mb-4">Begin by adding processes (P₁, P₂, etc.) and resources (R₁, R₂, etc.) to your system using the respective buttons. For each resource, specify how many instances are available.</p>
                                            <div class="tutorial-code-snippet p-3 rounded bg-gray-100 dark:bg-gray-800 text-sm font-mono mb-3">
                                                <span class="text-blue-800 dark:text-blue-400">// Example system setup</span><br>
                                                <span class="text-green-800 dark:text-green-400">Processes:</span> <span class="text-gray-900 dark:text-gray-200">P₁, P₂, P₃</span><br>
                                                <span class="text-purple-800 dark:text-purple-400">Resources:</span> <span class="text-gray-900 dark:text-gray-200">R₁(3 units), R₂(2 units)</span>
                                            </div>
                                            <div class="flex items-center text-sm text-primary-600 dark:text-primary-400">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                                </svg>
                                                Tip: Plan your system carefully before creating it!
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Step 2 -->
                            <div class="tutorial-card" data-step="2">
                                <div class="flex items-start md:items-center flex-col md:flex-row p-6 rounded-xl bg-opacity-60 bg-gray-50 dark:bg-gray-900 shadow-md transition-all duration-300 transform cursor-pointer">
                                    <div class="tutorial-step-number flex-shrink-0 w-12 h-12 rounded-full flex items-center justify-center text-white font-bold mb-4 md:mb-0 md:mr-6 bg-gray-400 dark:bg-gray-700" style="color: white !important; background: linear-gradient(135deg, #6b7280, #4b5563) !important;">2</div>
                                    <div class="tutorial-content flex-grow">
                                        <h3 class="font-bold text-xl mb-2 flex items-center">
                                            Allocate and Request Resources
                                        </h3>
                                        <div class="tutorial-details hidden">
                                            <p class="mb-4">Create relationships between processes and resources by:</p>
                                            <ul class="list-disc pl-5 mb-4 space-y-2">
                                                <li><span class="font-medium">Allocating resources</span>: Assign resource instances to processes that are currently using them</li>
                                                <li><span class="font-medium">Making requests</span>: Indicate when a process needs a resource that's currently unavailable</li>
                                            </ul>
                                            <div class="tutorial-illustration flex justify-center mb-3">
                                                <div class="relative p-3 border border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
                                                    <div class="process-bubble">P₁</div>
                                                    <svg class="allocation-arrow" viewBox="0 0 100 20"><path d="M0,10 L90,10" /></svg>
                                                    <div class="resource-bubble">R₁</div>
                                                    <div class="arrow-label">allocation</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Step 3 -->
                            <div class="tutorial-card" data-step="3">
                                <div class="flex items-start md:items-center flex-col md:flex-row p-6 rounded-xl bg-opacity-60 bg-gray-50 dark:bg-gray-900 shadow-md transition-all duration-300 transform cursor-pointer">
                                    <div class="tutorial-step-number flex-shrink-0 w-12 h-12 rounded-full flex items-center justify-center text-white font-bold mb-4 md:mb-0 md:mr-6 bg-gray-400 dark:bg-gray-700" style="color: white !important; background: linear-gradient(135deg, #6b7280, #4b5563) !important;">3</div>
                                    <div class="tutorial-content flex-grow">
                                        <h3 class="font-bold text-xl mb-2 flex items-center">
                                            Detect and Analyze Deadlocks
                                        </h3>
                                        <div class="tutorial-details hidden">
                                            <p class="mb-4">Click the "Detect Deadlock" button to analyze your system. The simulator will:</p>
                                            <ol class="list-decimal pl-5 mb-4 space-y-2">
                                                <li>Find cycles in the resource allocation graph</li>
                                                <li>Highlight any detected deadlocks with red indicators</li>
                                                <li>Provide detailed information about involved processes and resources</li>
                                            </ol>
                                            <div class="bg-red-50 dark:bg-red-900 dark:bg-opacity-30 p-3 rounded-lg border-l-4 border-red-500 mb-3">
                                                <h4 class="font-medium text-red-800 dark:text-red-400 mb-1">Deadlock Detected!</h4>
                                                <p class="text-sm text-red-900 dark:text-red-300">Processes P₁ and P₂ are in a deadlock state. P₁ is waiting for R₂ while holding R₁, and P₂ is waiting for R₁ while holding R₂.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Step 4 -->
                            <div class="tutorial-card" data-step="4">
                                <div class="flex items-start md:items-center flex-col md:flex-row p-6 rounded-xl bg-opacity-60 bg-gray-50 dark:bg-gray-900 shadow-md transition-all duration-300 transform cursor-pointer">
                                    <div class="tutorial-step-number flex-shrink-0 w-12 h-12 rounded-full flex items-center justify-center text-white font-bold mb-4 md:mb-0 md:mr-6 bg-gray-400 dark:bg-gray-700" style="color: white !important; background: linear-gradient(135deg, #6b7280, #4b5563) !important;">4</div>
                                    <div class="tutorial-content flex-grow">
                                        <h3 class="font-bold text-xl mb-2 flex items-center">
                                            Resolve Deadlocks
                                            <span class="ml-2 tutorial-badge px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-800 dark:bg-blue-800 dark:text-blue-100">Advanced</span>
                                        </h3>
                                        <div class="tutorial-details hidden">
                                            <p class="mb-4">Apply different resolution strategies to break deadlocks:</p>
                                            <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
                                                <div class="resolution-method p-3 rounded bg-indigo-50 dark:bg-indigo-900 dark:bg-opacity-30">
                                                    <h5 class="font-medium mb-1">Resource Preemption</h5>
                                                    <p class="text-sm">Temporarily take resources away from processes</p>
                                                </div>
                                                <div class="resolution-method p-3 rounded bg-purple-50 dark:bg-purple-900 dark:bg-opacity-30">
                                                    <h5 class="font-medium mb-1">Process Termination</h5>
                                                    <p class="text-sm">Terminate one or more deadlocked processes</p>
                                                </div>
                                                <div class="resolution-method p-3 rounded bg-pink-50 dark:bg-pink-900 dark:bg-opacity-30">
                                                    <h5 class="font-medium mb-1">Deadlock Avoidance</h5>
                                                    <p class="text-sm">Implement resource allocation strategies</p>
                                                </div>
                                                <div class="resolution-method p-3 rounded bg-yellow-50 dark:bg-yellow-900 dark:bg-opacity-30">
                                                    <h5 class="font-medium mb-1">Resource Management</h5>
                                                    <p class="text-sm">Optimize resource usage patterns</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Button -->
                        <div class="mt-10 text-center">
                            <a href="index.html" class="try-simulator-btn inline-flex items-center px-8 py-4 rounded-xl text-white font-bold text-lg shadow-lg hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1 bg-gradient-to-r from-primary-500 to-primary-600" style="color: white !important; background: linear-gradient(to right, #3b82f6, #2563eb) !important; border: none !important;">
                                <span>Try the Simulator</span>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2 animate-pulse" viewBox="0 0 20 20" fill="currentColor" style="fill: white !important;">
                                    <path fill-rule="evenodd" d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </a>
                        </div>
                    </div>
                </div>
            </section>

            <style>
                .tutorial-glow {
                    text-shadow: 0 0 15px rgba(var(--primary-rgb), 0.3);
                }
                
                .tutorial-card.active .tutorial-details {
                    display: block;
                }
                
                .tutorial-card:not(.active) .tutorial-details {
                    display: none;
                }
                
                .tutorial-card.active {
                    transform: translateY(-5px);
                }
                
                .tutorial-card:not(.active):hover {
                    transform: translateY(-3px);
                    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                }
                
                .tutorial-step-number {
                    transition: all 0.3s ease;
                }
                
                .tutorial-card.active .tutorial-step-number {
                    transform: scale(1.05);
                    box-shadow: 0 6px 15px rgba(var(--primary-rgb), 0.35);
                }
                
                /* Process and resource styling - matched with existing elements */
                .tutorial-illustration {
                    background: var(--card-bg);
                    border-radius: 8px;
                    padding: 20px;
                    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
                    margin-bottom: 16px;
                    position: relative;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                }
                
                .process-bubble, .resource-bubble {
                    width: 50px;
                    height: 50px;
                    border-radius: 50%;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    margin: 0 30px;
                    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
                    position: relative;
                    z-index: 2;
                }
                
                .process-bubble {
                    background: linear-gradient(135deg, var(--process-color-1), var(--process-color-2));
                    color: white;
                }
                
                .resource-bubble {
                    background: linear-gradient(135deg, var(--resource-color-1), var(--resource-color-2));
                    color: white;
                }
                
                /* Arrow styling - aligned with app style */
                .allocation-arrow {
                    position: absolute;
                    top: 50%;
                    left: 0;
                    width: 100%;
                    height: 10px;
                    stroke: var(--primary-500);
                    stroke-width: 1.5;
                    fill: none;
                    stroke-dasharray: 6 3;
                    animation: dashOffset 25s linear infinite;
                    z-index: 1;
                    opacity: 0.9;
                }
                
                .arrow-label {
                    position: absolute;
                    bottom: -8px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 0.7rem;
                    font-weight: 500;
                    color: var(--text-secondary);
                    background: var(--glass-bg);
                    border: 1px solid var(--border-color);
                    padding: 2px 8px;
                    border-radius: 4px;
                }
                
                @keyframes dashOffset {
                    from {
                        stroke-dashoffset: 0;
                    }
                    to {
                        stroke-dashoffset: 500;
                    }
                }
                
                @keyframes fadeIn {
                    from {
                        opacity: 0;
                        transform: translateY(5px);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }
                
                /* Tutorial progress bar */
                .tutorial-progress {
                    padding: 0 10px;
                }
                
                .tutorial-progress-bar {
                    transition: width 0.7s cubic-bezier(0.65, 0, 0.35, 1);
                    box-shadow: 0 1px 3px rgba(var(--primary-rgb), 0.3);
                }
                
                /* Button styling - aligned with other buttons */
                .try-simulator-btn {
                    position: relative;
                    overflow: hidden;
                    transition: all 0.3s ease;
                    border: none;
                    box-shadow: 0 4px 12px rgba(var(--primary-rgb), 0.25);
                }
                
                .try-simulator-btn:hover {
                    box-shadow: 0 6px 16px rgba(var(--primary-rgb), 0.35);
                }
                
                .try-simulator-btn::after {
                    content: '';
                    position: absolute;
                    top: -50%;
                    left: -50%;
                    width: 200%;
                    height: 200%;
                    background: linear-gradient(
                        to bottom right,
                        rgba(255, 255, 255, 0) 0%,
                        rgba(255, 255, 255, 0.05) 40%,
                        rgba(255, 255, 255, 0.2) 50%,
                        rgba(255, 255, 255, 0.05) 60%,
                        rgba(255, 255, 255, 0) 100%
                    );
                    transform: rotate(45deg);
                    animation: shine 3.5s cubic-bezier(0.4, 0, 0.2, 1) infinite;
                }
                
                @keyframes shine {
                    0% {
                        left: -100%;
                        top: -100%;
                    }
                    100% {
                        left: 100%;
                        top: 100%;
                    }
                }
                
                /* Dark mode enhancements */
                [data-theme="dark"] .tutorial-card.active {
                    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
                    border-color: var(--primary-500);
                }
                
                [data-theme="dark"] .tutorial-illustration {
                    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
                }
                
                [data-theme="dark"] .resolution-method {
                    color: rgba(255, 255, 255, 0.9);
                }
                
                [data-theme="dark"] .tutorial-code-snippet {
                    border: 1px solid var(--border-color);
                }
            </style>
            
            <script>
                // Tutorial animation script - will be added by DOMContentLoaded
                document.addEventListener('DOMContentLoaded', function() {
                    const tutorialCards = document.querySelectorAll('.tutorial-card');
                    const progressBar = document.querySelector('.tutorial-progress-bar');
                    const tutorialCanvas = document.getElementById('tutorialCanvas');
                    
                    // Initialize canvas animation
                    if (tutorialCanvas) {
                        const ctx = tutorialCanvas.getContext('2d');
                        const particles = [];
                        
                        // Resize canvas to fill container
                        function resizeCanvas() {
                            const tutorialSection = tutorialCanvas.closest('section');
                            tutorialCanvas.width = tutorialSection.offsetWidth;
                            tutorialCanvas.height = tutorialSection.offsetHeight;
                        }
                        
                        // Create particles
                        function createParticles() {
                            for (let i = 0; i < 30; i++) {
                                particles.push({
                                    x: Math.random() * tutorialCanvas.width,
                                    y: Math.random() * tutorialCanvas.height,
                                    radius: Math.random() * 2 + 1,
                                    speedX: Math.random() * 1 - 0.5,
                                    speedY: Math.random() * 1 - 0.5,
                                    color: document.documentElement.getAttribute('data-theme') === 'dark' 
                                        ? `rgba(100, 100, 255, ${Math.random() * 0.2 + 0.1})` 
                                        : `rgba(100, 100, 255, ${Math.random() * 0.15 + 0.05})`
                                });
                            }
                        }
                        
                        // Draw particles and connections
                        function drawParticles() {
                            ctx.clearRect(0, 0, tutorialCanvas.width, tutorialCanvas.height);
                            
                            const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                            const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
                            
                            // Move and draw particles
                            particles.forEach(p => {
                                p.x += p.speedX;
                                p.y += p.speedY;
                                
                                // Wrap around edges
                                if (p.x < 0) p.x = tutorialCanvas.width;
                                if (p.x > tutorialCanvas.width) p.x = 0;
                                if (p.y < 0) p.y = tutorialCanvas.height;
                                if (p.y > tutorialCanvas.height) p.y = 0;
                                
                                // Draw particle
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                                
                                // Use high contrast colors if needed
                                if (isHighContrast) {
                                    ctx.fillStyle = isDarkTheme ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)';
                                } else {
                                    ctx.fillStyle = p.color;
                                }
                                
                                ctx.fill();
                            });
                            
                            // Draw connections between nearby particles
                            for (let i = 0; i < particles.length; i++) {
                                for (let j = i + 1; j < particles.length; j++) {
                                    const dx = particles[i].x - particles[j].x;
                                    const dy = particles[i].y - particles[j].y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < 100) {
                                        ctx.beginPath();
                                        
                                        // Use high contrast colors if needed
                                        if (isHighContrast) {
                                            ctx.strokeStyle = isDarkTheme 
                                                ? `rgba(255, 255, 255, ${0.15 * (1 - distance / 100)})` 
                                                : `rgba(0, 0, 0, ${0.15 * (1 - distance / 100)})`;
                                        } else {
                                            ctx.strokeStyle = isDarkTheme
                                                ? `rgba(100, 100, 255, ${0.1 * (1 - distance / 100)})`
                                                : `rgba(100, 100, 255, ${0.05 * (1 - distance / 100)})`;
                                        }
                                        
                                        ctx.lineWidth = isHighContrast ? 1.5 : 1;
                                        ctx.moveTo(particles[i].x, particles[i].y);
                                        ctx.lineTo(particles[j].x, particles[j].y);
                                        ctx.stroke();
                                    }
                                }
                            }
                            
                            requestAnimationFrame(drawParticles);
                        }
                        
                        // Initialize canvas
                        window.addEventListener('resize', resizeCanvas);
                        resizeCanvas();
                        createParticles();
                        drawParticles();
                    }
                    
                    // Set up tutorial cards interactivity
                    tutorialCards.forEach((card, index) => {
                        card.addEventListener('click', () => {
                            // Remove active class from all cards
                            tutorialCards.forEach(c => c.classList.remove('active'));
                            
                            // Make the clicked card active
                            card.classList.add('active');
                            
                            // Update progress bar
                            const progress = ((index + 1) / tutorialCards.length) * 100;
                            progressBar.style.width = `${progress}%`;
                        });
                    });
                    
                    // Fix theme integration for tutorial elements
                    function fixTutorialThemeElements() {
                        const isLightTheme = document.documentElement.getAttribute('data-theme') !== 'dark';
                        const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                        
                        // Fix tutorial badges
                        document.querySelectorAll('.tutorial-badge').forEach(badge => {
                            if (isHighContrast) {
                                badge.style.backgroundColor = isLightTheme ? '#ffffff' : '#000000';
                                badge.style.color = isLightTheme ? '#000000' : '#ffffff';
                                badge.style.border = isLightTheme ? '2px solid #000000' : '2px solid #ffffff';
                            } else {
                                badge.style.backgroundColor = 'var(--bg-secondary)';
                                badge.style.color = 'var(--text-primary)';
                                badge.style.border = '1px solid var(--border-color)';
                            }
                        });
                        
                        // Fix code snippets
                        document.querySelectorAll('.tutorial-code-snippet').forEach(snippet => {
                            if (isHighContrast) {
                                snippet.style.backgroundColor = isLightTheme ? '#ffffff' : '#000000';
                                snippet.style.color = isLightTheme ? '#000000' : '#ffffff';
                                snippet.style.border = isLightTheme ? '2px solid #000000' : '2px solid #ffffff';
                                
                                // Fix all child elements text colors in high contrast mode
                                snippet.querySelectorAll('*').forEach(el => {
                                    el.style.color = isLightTheme ? '#000000' : '#ffffff';
                                });
                            } else {
                                snippet.style.backgroundColor = 'var(--panel-bg)';
                                snippet.style.border = '1px solid var(--border-color)';
                                
                                // Fix specific text elements in normal contrast mode
                                snippet.querySelectorAll('span').forEach(el => {
                                    // Keep the specialized classes but ensure text is always visible
                                    if (el.classList.contains('text-blue-800') || el.classList.contains('text-blue-600') || el.classList.contains('text-blue-400')) {
                                        el.style.color = isLightTheme ? '#1e40af' : '#60a5fa'; // dark blue in light mode, light blue in dark mode
                                    }
                                    else if (el.classList.contains('text-green-800') || el.classList.contains('text-green-600') || el.classList.contains('text-green-400')) {
                                        el.style.color = isLightTheme ? '#166534' : '#4ade80'; // dark green in light mode, light green in dark mode
                                    }
                                    else if (el.classList.contains('text-purple-800') || el.classList.contains('text-purple-600') || el.classList.contains('text-purple-400')) {
                                        el.style.color = isLightTheme ? '#581c87' : '#c084fc'; // dark purple in light mode, light purple in dark mode
                                    }
                                    else if (el.classList.contains('text-gray-900') || el.classList.contains('text-gray-200')) {
                                        el.style.color = isLightTheme ? '#111827' : '#e5e7eb'; // dark gray in light mode, light gray in dark mode
                                    }
                                });
                            }
                        });
                        
                        // Fix resolution methods
                        document.querySelectorAll('.resolution-method').forEach(method => {
                            if (isHighContrast) {
                                method.style.backgroundColor = isLightTheme ? '#ffffff' : '#000000';
                                method.style.color = isLightTheme ? '#000000' : '#ffffff';
                                method.style.border = isLightTheme ? '2px solid #000000' : '2px solid #ffffff';
                            } else {
                                method.style.backgroundColor = 'var(--bg-secondary)';
                                method.style.color = 'var(--text-primary)';
                                method.style.border = '1px solid var(--border-color)';
                            }
                        });
                        
                        // Fix tutorial cards backgrounds
                        document.querySelectorAll('.tutorial-card > div').forEach(cardContent => {
                            if (isHighContrast) {
                                cardContent.style.backgroundColor = isLightTheme ? '#ffffff' : '#000000';
                                cardContent.style.backdropFilter = 'none';
                                cardContent.style.WebkitBackdropFilter = 'none';
                                cardContent.style.border = isLightTheme ? '2px solid #000000' : '2px solid #ffffff';
                            } else {
                                cardContent.style.backgroundColor = 'transparent';
                                cardContent.style.backdropFilter = 'blur(10px)';
                                cardContent.style.WebkitBackdropFilter = 'blur(10px)';
                                cardContent.style.border = '1px solid var(--border-color)';
                            }
                        });
                        
                        // Fix process and resource bubbles
                        document.querySelectorAll('.process-bubble, .resource-bubble').forEach(bubble => {
                            if (isHighContrast) {
                                bubble.style.background = isLightTheme ? '#000000' : '#ffffff';
                                bubble.style.color = isLightTheme ? '#ffffff' : '#000000';
                                bubble.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                if (bubble.classList.contains('process-bubble')) {
                                    bubble.style.background = 'linear-gradient(135deg, var(--process-color-1), var(--process-color-2))';
                                } else {
                                    bubble.style.background = 'linear-gradient(135deg, var(--resource-color-1), var(--resource-color-2))';
                                }
                                bubble.style.color = 'white';
                                bubble.style.border = 'none';
                            }
                        });
                        
                        // Fix step numbers
                        document.querySelectorAll('.tutorial-step-number').forEach(step => {
                            if (isHighContrast) {
                                step.style.background = isLightTheme ? '#000000' : '#ffffff';
                                step.style.color = isLightTheme ? '#ffffff' : '#000000';
                                step.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                step.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
                                step.style.color = '#ffffff';
                                step.style.border = 'none';
                                // Add !important to background and color
                                step.setAttribute('style', step.getAttribute('style') + ' background: linear-gradient(135deg, #3b82f6, #2563eb) !important; color: #ffffff !important; border: none !important;');
                            }
                        });
                        
                        // Fix try simulator button
                        const simulatorBtn = document.querySelector('.try-simulator-btn');
                        if (simulatorBtn) {
                            if (isHighContrast) {
                                simulatorBtn.style.background = isLightTheme ? '#000000' : '#ffffff';
                                simulatorBtn.style.color = isLightTheme ? '#ffffff' : '#000000';
                                simulatorBtn.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                simulatorBtn.style.background = 'linear-gradient(to right, #3b82f6, #2563eb)';
                                simulatorBtn.style.color = '#ffffff';
                                simulatorBtn.style.border = 'none';
                                // Add !important to background and color
                                simulatorBtn.setAttribute('style', simulatorBtn.getAttribute('style') + ' background: linear-gradient(to right, #3b82f6, #2563eb) !important; color: #ffffff !important; border: none !important;');
                                
                                // Make sure the SVG inside the button is also white
                                const svgIcon = simulatorBtn.querySelector('svg');
                                if (svgIcon) {
                                    svgIcon.style.fill = '#ffffff';
                                    svgIcon.setAttribute('style', svgIcon.getAttribute('style') + ' fill: #ffffff !important;');
                                }
                            }
                        }
                        
                        // Fix canvas particles for high contrast
                        if (isHighContrast) {
                            const canvas = document.getElementById('tutorialCanvas');
                            if (canvas) {
                                canvas.style.opacity = '0.1';
                            }
                        } else {
                            const canvas = document.getElementById('tutorialCanvas');
                            if (canvas) {
                                canvas.style.opacity = '0.3';
                            }
                        }
                        
                        // Fix process elements in the operating systems section
                        const processSlots = document.querySelectorAll('.process-slot');
                        const processBlocks = document.querySelectorAll('.process-block');
                        const processBubbles = document.querySelectorAll('.process-bubble');
                        
                        // Process slots (ready queue, CPU, blocked queue)
                        processSlots.forEach(slot => {
                            if (isHighContrast) {
                                slot.style.background = isLightTheme ? '#000000' : '#ffffff';
                                slot.style.color = isLightTheme ? '#ffffff' : '#000000';
                                slot.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                slot.style.background = '';
                                slot.style.color = '';
                                slot.style.border = '';
                            }
                        });
                        
                        // Process blocks (P1, P2 in allocation section)
                        processBlocks.forEach(block => {
                            if (isHighContrast) {
                                block.style.background = isLightTheme ? '#000000' : '#ffffff';
                                block.style.color = isLightTheme ? '#ffffff' : '#000000';
                                block.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                block.style.background = 'linear-gradient(135deg, var(--process-color-1), var(--process-color-2))';
                                block.style.color = 'white';
                                block.style.border = 'none';
                            }
                        });
                        
                        // Process bubbles (in tutorial examples)
                        processBubbles.forEach(bubble => {
                            if (isHighContrast) {
                                bubble.style.background = isLightTheme ? '#000000' : '#ffffff';
                                bubble.style.color = isLightTheme ? '#ffffff' : '#000000';
                                bubble.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                bubble.style.background = 'linear-gradient(135deg, var(--process-color-1), var(--process-color-2))';
                                bubble.style.color = 'white';
                                bubble.style.border = 'none';
                            }
                        });
                        
                        // Fix process buttons
                        const processButtons = document.querySelectorAll('.process-btn');
                        processButtons.forEach(btn => {
                            if (isHighContrast) {
                                btn.style.background = isLightTheme ? '#000000' : '#ffffff';
                                btn.style.color = isLightTheme ? '#ffffff' : '#000000';
                                btn.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                btn.style.background = 'linear-gradient(135deg, var(--process-color-1), var(--process-color-2))';
                                btn.style.color = 'white';
                                btn.style.border = 'none';
                            }
                        });
                        
                        // Fix Simulate Allocation button
                        const allocateBtn = document.querySelector('.allocate-btn');
                        if (allocateBtn) {
                            if (isHighContrast) {
                                allocateBtn.style.background = isLightTheme ? '#000000' : '#ffffff';
                                allocateBtn.style.color = isLightTheme ? '#ffffff' : '#000000';
                                allocateBtn.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                            } else {
                                allocateBtn.style.background = 'linear-gradient(135deg, var(--process-color-1), var(--process-color-2))';
                                allocateBtn.style.color = 'white';
                                allocateBtn.style.border = 'none';
                            }
                        }
                        
                        // Fix Master the Simulator title
                        const tutorialTitle = document.querySelector('h2.tutorial-glow');
                        if (tutorialTitle) {
                            if (isHighContrast) {
                                tutorialTitle.style.backgroundColor = 'transparent';
                                tutorialTitle.style.color = isLightTheme ? '#000000' : '#ffffff';
                                tutorialTitle.style.textShadow = 'none';
                                tutorialTitle.style.border = 'none';
                                tutorialTitle.style.padding = '0';
                                tutorialTitle.style.borderRadius = '0';
                                tutorialTitle.style.boxShadow = 'none';
                                
                                // Add !important to make sure these styles are applied
                                tutorialTitle.setAttribute('style', tutorialTitle.getAttribute('style') + 
                                ' background-color: transparent !important;' +
                                ' color: ' + (isLightTheme ? '#000000' : '#ffffff') + ' !important;' +
                                ' text-shadow: none !important;' +
                                ' border: none !important;' +
                                ' box-shadow: none !important;' +
                                ' padding: 0 !important;' +
                                ' border-radius: 0 !important;');
                            } else {
                                tutorialTitle.style.backgroundColor = 'transparent';
                                tutorialTitle.style.color = 'var(--text-primary)';
                                tutorialTitle.style.textShadow = '0 0 15px rgba(var(--primary-rgb), 0.3)';
                                tutorialTitle.style.border = 'none';
                                tutorialTitle.style.padding = '0';
                                tutorialTitle.style.borderRadius = '0';
                                tutorialTitle.style.boxShadow = 'none';
                            }
                        }
                        
                        // Fix deadlock message box for better visibility
                        const deadlockBox = document.querySelector('.bg-red-50.dark\\:bg-red-900');
                        if (deadlockBox) {
                            if (isHighContrast) {
                                // High contrast mode
                                deadlockBox.style.backgroundColor = isLightTheme ? 'white' : 'black';
                                deadlockBox.style.borderLeft = isLightTheme ? '4px solid black' : '4px solid white';
                                
                                // Fix title and text in high contrast mode
                                const deadlockTitle = deadlockBox.querySelector('h4');
                                if (deadlockTitle) {
                                    deadlockTitle.style.color = isLightTheme ? 'black' : 'white';
                                    deadlockTitle.style.fontWeight = 'bold';
                                }
                                
                                const deadlockText = deadlockBox.querySelector('p');
                                if (deadlockText) {
                                    deadlockText.style.color = isLightTheme ? 'black' : 'white';
                                }
                            } else {
                                // Normal contrast mode - ensure good visibility in both themes
                                if (isLightTheme) {
                                    // Light theme
                                    deadlockBox.style.backgroundColor = 'rgb(254, 226, 226)';
                                    deadlockBox.style.borderLeftColor = 'rgb(220, 38, 38)';
                                    
                                    const deadlockTitle = deadlockBox.querySelector('h4');
                                    if (deadlockTitle) {
                                        deadlockTitle.style.color = 'rgb(127, 29, 29)';
                                    }
                                    
                                    const deadlockText = deadlockBox.querySelector('p');
                                    if (deadlockText) {
                                        deadlockText.style.color = 'rgb(153, 27, 27)';
                                    }
                                } else {
                                    // Dark theme
                                    deadlockBox.style.backgroundColor = 'rgba(127, 29, 29, 0.3)';
                                    deadlockBox.style.borderLeftColor = 'rgb(248, 113, 113)';
                                    
                                    const deadlockTitle = deadlockBox.querySelector('h4');
                                    if (deadlockTitle) {
                                        deadlockTitle.style.color = 'rgb(252, 165, 165)';
                                    }
                                    
                                    const deadlockText = deadlockBox.querySelector('p');
                                    if (deadlockText) {
                                        deadlockText.style.color = 'rgb(254, 202, 202)';
                                    }
                                }
                            }
                        }
                    }
                    
                    // Call on initial load
                    fixTutorialThemeElements();
                    
                    // Call when theme toggle is clicked
                    document.getElementById('themeToggle').addEventListener('click', () => {
                        setTimeout(fixTutorialThemeElements, 50);
                    });
                    
                    // Call when contrast toggle is clicked
                    document.getElementById('contrastToggle').addEventListener('click', () => {
                        setTimeout(fixTutorialThemeElements, 50);
                    });
                });
            </script>
        </main>
    </div>

    <script>
        // Theme and contrast toggle functionality
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggle = document.getElementById('themeToggle');
            const contrastToggle = document.getElementById('contrastToggle');
            
            // Check for saved theme preference or use default
            const savedTheme = localStorage.getItem('deadlock-theme') || 'light';
            const savedContrast = localStorage.getItem('deadlock-contrast') || 'normal';
            
            // Apply saved settings
            document.documentElement.setAttribute('data-theme', savedTheme);
            if (savedContrast === 'high') {
                document.documentElement.setAttribute('data-contrast', 'high');
            }
            
            // Toggle theme on click
            themeToggle.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('deadlock-theme', newTheme);
            });
            
            // Toggle contrast on click
            contrastToggle.addEventListener('click', function() {
                const currentContrast = document.documentElement.getAttribute('data-contrast');
                const newContrast = currentContrast === 'high' ? 'normal' : 'high';
                
                if (newContrast === 'normal') {
                    document.documentElement.removeAttribute('data-contrast');
                } else {
                    document.documentElement.setAttribute('data-contrast', newContrast);
                }
                
                localStorage.setItem('deadlock-contrast', newContrast);
            });
            
            // Initialize the fancy navbar
            initNavbar();
            
            // Initialize expandable cards
            initExpandableCards();
            
            // Initialize new features
            initResourceCards();
            initResourceAllocation();
        });
        
        // Initialize the fancy navbar with indicator animations
        function initNavbar() {
            const navContainer = document.querySelector('.navbar-container');
            const navButtons = document.querySelectorAll('.nav-button');
            const navIndicator = document.querySelector('.nav-indicator');
            
            // Track screen size to prevent unnecessary updates
            let lastWidth = window.innerWidth;
            let isPositioning = false;
            
            // Set initial indicator position
            function positionIndicator() {
                // Prevent concurrent positioning operations
                if (isPositioning) return;
                isPositioning = true;
                
                const activeButton = document.querySelector('.nav-button.active');
                if (!activeButton || !navIndicator) {
                    isPositioning = false;
                    return;
                }
                
                // Force a single, stable calculation
                const isMobile = window.innerWidth <= 768;
                
                try {
                    const rect = activeButton.getBoundingClientRect();
                    const containerRect = navContainer.getBoundingClientRect();
                    
                    // Batch all style changes together to prevent multiple reflows
                    requestAnimationFrame(() => {
                        if (isMobile) {
                            // Mobile layout (vertical)
                            navIndicator.style.cssText = `
                                display: block;
                                opacity: 1;
                                width: ${rect.width}px;
                                height: ${rect.height}px;
                                top: ${rect.top - containerRect.top}px;
                                left: 6px;
                            `;
                        } else {
                            // Desktop layout (horizontal)
                            navIndicator.style.cssText = `
                                display: block;
                                opacity: 1;
                                width: ${rect.width}px;
                                height: calc(100% - 12px);
                                left: ${rect.left - containerRect.left}px;
                                top: 6px;
                            `;
                        }
                        isPositioning = false;
                    });
                } catch (err) {
                    console.warn('Error positioning nav indicator:', err);
                    
                    // Use a more stable fallback method
                    requestAnimationFrame(() => {
                        const index = Array.from(navButtons).findIndex(btn => btn.classList.contains('active'));
                        if (index >= 0) {
                            if (!isMobile) {
                                // Horizontal fallback
                                const buttonWidth = navContainer.clientWidth / navButtons.length;
                                navIndicator.style.cssText = `
                                    display: block;
                                    opacity: 1;
                                    width: ${buttonWidth}px;
                                    height: calc(100% - 12px);
                                    left: ${index * buttonWidth}px;
                                    top: 6px;
                                `;
                            } else {
                                // Vertical fallback
                                const buttonHeight = navContainer.clientHeight / navButtons.length;
                                navIndicator.style.cssText = `
                                    display: block;
                                    opacity: 1;
                                    height: ${buttonHeight}px;
                                    width: calc(100% - 12px);
                                    top: ${index * buttonHeight}px;
                                    left: 6px;
                                `;
                            }
                        }
                        isPositioning = false;
                    });
                }
            }
            
            // Initial positioning - only once after DOMContentLoaded
            window.addEventListener('DOMContentLoaded', () => {
                setTimeout(positionIndicator, 300);
            });
            
            // Position after page is fully loaded
            window.addEventListener('load', () => {
                setTimeout(positionIndicator, 200);
            });
            
            // Update on resize with debounce and threshold check
            let resizeTimer;
            window.addEventListener('resize', () => {
                // Only trigger if width changed by at least 5px to avoid subtle height changes
                if (Math.abs(lastWidth - window.innerWidth) > 5) {
                    lastWidth = window.innerWidth;
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(positionIndicator, 200);
                }
            });
            
            // Set up button hover effects
            navButtons.forEach(button => {
                button.addEventListener('mouseenter', () => {
                    // Create ripple effect on hover
                    button.querySelector('.nav-button-background').style.opacity = '0.6';
                    button.querySelector('.nav-button-background').style.transform = 'scale(1.8)';
                    
                    // Add floating particles
                    if (!button.classList.contains('active')) {
                        const particle = document.createElement('div');
                        particle.className = 'nav-particle';
                        particle.style.cssText = `
                            position: absolute;
                            width: 5px;
                            height: 5px;
                            background: var(--process-color-2);
                            border-radius: 50%;
                            filter: blur(2px);
                            opacity: 0.7;
                            top: ${Math.random() * 100}%;
                            left: ${Math.random() * 100}%;
                            pointer-events: none;
                            z-index: 3;
                        `;
                        button.appendChild(particle);
                        
                        // Animate particle
                        const animation = particle.animate([
                            { transform: 'translateY(0) translateX(0)', opacity: 0.7 },
                            { transform: `translateY(-${20 + Math.random() * 30}px) translateX(${Math.random() * 20 - 10}px)`, opacity: 0 }
                        ], {
                            duration: 1000 + Math.random() * 1000,
                            easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)',
                        });
                        
                        animation.onfinish = () => {
                            particle.remove();
                        };
                    }
                });
                
                button.addEventListener('mouseleave', () => {
                    button.querySelector('.nav-button-background').style.opacity = '0';
                    button.querySelector('.nav-button-background').style.transform = 'scale(0.5)';
                });
                
                // Create glow pulse effect for active button
                if (button.classList.contains('active')) {
                    // Pulse glow effect
                    setInterval(() => {
                        if (button.classList.contains('active')) {
                            const glow = document.createElement('div');
                            glow.className = 'active-glow';
                            
                            // Check for high contrast mode
                            const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                            const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
                            
                            if (isHighContrast) {
                                // High contrast glow effect
                                glow.style.cssText = `
                                    position: absolute;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    border-radius: 50px;
                                    background: ${isDarkTheme ? '#ffffff' : '#000000'};
                                    opacity: ${isDarkTheme ? '0.5' : '0.3'};
                                    z-index: 0;
                                    pointer-events: none;
                                    border: 2px solid ${isDarkTheme ? '#ffffff' : '#000000'};
                                `;
                            } else {
                                // Standard glow effect
                                glow.style.cssText = `
                                    position: absolute;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    border-radius: 50px;
                                    background: var(--process-color-1);
                                    opacity: 0.2;
                                    z-index: 0;
                                    pointer-events: none;
                                `;
                            }
                            
                            button.appendChild(glow);
                            
                            const animation = glow.animate([
                                { transform: 'scale(0.9)', opacity: isHighContrast ? (isDarkTheme ? 0.5 : 0.3) : 0.3 },
                                { transform: 'scale(1.05)', opacity: 0 }
                            ], {
                                duration: 2000,
                                easing: 'ease-out'
                            });
                            
                            animation.onfinish = () => {
                                glow.remove();
                            };
                        }
                    }, 3000);
                }
            });
            
            // Call positionIndicator immediately
            positionIndicator();
        }
        
        // Initialize expandable cards
        function initExpandableCards() {
            const expandableCards = document.querySelectorAll('.expandable-card');
            
            expandableCards.forEach(card => {
                // Set initial state
                const content = card.querySelector('.expandable-content');
                
                // First card expanded by default
                if (card === expandableCards[0]) {
                    card.classList.add('expanded');
                    content.style.maxHeight = '1000px';
                }
                
                card.addEventListener('click', function(e) {
                    // Don't toggle if clicking on a link or interactive element inside
                    if (e.target.tagName === 'A' || e.target.tagName === 'BUTTON' || 
                        e.target.closest('a') || e.target.closest('button')) {
                        return;
                    }
                    
                    // Don't toggle if clicking on the content area when already expanded
                    if (card.classList.contains('expanded') && 
                        e.target.closest('.expandable-content') && 
                        e.target !== content) {
                        return;
                    }
                    
                    card.classList.toggle('expanded');
                    
                    // Toggle content height
                    if (card.classList.contains('expanded')) {
                        content.style.maxHeight = '1000px';
                    } else {
                        content.style.maxHeight = '0';
                    }
                    
                    // Create ripple effect
                    const createRipple = (e) => {
                        const ripple = document.createElement('div');
                        const rect = card.getBoundingClientRect();
                        
                        ripple.style.cssText = `
                            position: absolute;
                            width: 5px;
                            height: 5px;
                            background: var(--process-color-2);
                            border-radius: 50%;
                            pointer-events: none;
                            transform: translate(-50%, -50%);
                            animation: ripple-effect 0.8s linear;
                        `;
                        
                        ripple.style.left = `${e.clientX - rect.left}px`;
                        ripple.style.top = `${e.clientY - rect.top}px`;
                        
                        card.appendChild(ripple);
                        
                        setTimeout(() => {
                            ripple.remove();
                        }, 800);
                    };
                    
                    createRipple(e);
                });
            });
        }
        
        // Create keyframes for ripple effect
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            @keyframes ripple-effect {
                0% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                }
                100% {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(50);
                }
            }
        `;
        document.head.appendChild(styleSheet);
        
        // Initialize Resource Cards with hover effects
        function initResourceCards() {
            const resourceCards = document.querySelectorAll('.resource-3d-card');
            
            resourceCards.forEach(card => {
                // Add floating animation for cards
                setInterval(() => {
                    if (!card.classList.contains('floating')) {
                        card.classList.add('floating');
                        card.style.animation = `cardFloat ${3 + Math.random() * 2}s ease-in-out`;
                        
                        setTimeout(() => {
                            card.classList.remove('floating');
                            card.style.animation = '';
                        },0);
                    }
                }, 10000 + Math.random() * 5000);
                
                // Add glow pulse effect
                setInterval(() => {
                    card.querySelector('.resource-card-inner').style.animation = `glowPulse 2s ease-in-out`;
                    
                    setTimeout(() => {
                        card.querySelector('.resource-card-inner').style.animation = '';
                    }, 2000);
                }, 7000 + Math.random() * 5000);
                
                // Better click/touch handling
                card.addEventListener('click', (e) => {
                    // Toggle flipped state for mobile devices
                    if (window.matchMedia('(hover: none)').matches) {
                        e.preventDefault();
                        // Toggle the flipped class instead of relying on hover
                        card.classList.toggle('flipped');
                    }
                    
                    // Create particles without disrupting layout
                    setTimeout(() => {
                        for (let i = 0; i < 5; i++) {
                            createParticle(card);
                        }
                    }, 10);
                });
                
                // Add touch events for better mobile handling
                card.addEventListener('touchstart', () => {
                    card.style.transform = 'translateZ(0)'; // Prevent zoom issues
                }, { passive: true });
            });
            
            function createParticle(parent) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.cssText = `
                    position: absolute;
                    width: 8px;
                    height: 8px;
                    background: var(--process-color-2);
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 10;
                    opacity: 0.7;
                `;
                
                // Random position within the card
                const rect = parent.getBoundingClientRect();
                const x = Math.random() * rect.width;
                const y = Math.random() * rect.height;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                parent.appendChild(particle);
                
                // Animate particle
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const tx = Math.cos(angle) * 100 * speed;
                const ty = Math.sin(angle) * 100 * speed;
                
                const animation = particle.animate([
                    { transform: 'translate(0, 0)', opacity: 0.7 },
                    { transform: `translate(${tx}px, ${ty}px)`, opacity: 0 }
                ], {
                    duration: 1000 + Math.random() * 500,
                    easing: 'cubic-bezier(0, .9, .57, 1)',
                });
                
                animation.onfinish = () => particle.remove();
            }
        }
        
        // Initialize Resource Allocation Animation
        function initResourceAllocation() {
            const allocateBtn = document.getElementById('allocateBtn');
            const message = document.getElementById('allocationMessage');
            const process1 = document.getElementById('process1');
            const process2 = document.getElementById('process2');
            const resource1 = document.getElementById('resource1');
            const resource2 = document.getElementById('resource2');
            const arrowsContainer = document.querySelector('.allocation-arrows');
            
            let state = 0;
            const states = [
                { message: "Click to begin resource allocation simulation" },
                { 
                    message: "P1 allocated 1 unit from R1", 
                    arrows: [{ from: 'resource1', to: 'process1', type: 'allocation' }],
                    allocate: { resource: 'resource1', unit: 0 }
                },
                { 
                    message: "P2 allocated 1 unit from R2", 
                    arrows: [
                        { from: 'resource1', to: 'process1', type: 'allocation' },
                        { from: 'resource2', to: 'process2', type: 'allocation' }
                    ],
                    allocate: { resource: 'resource2', unit: 0 }
                },
                { 
                    message: "P1 requests 1 unit from R2", 
                    arrows: [
                        { from: 'resource1', to: 'process1', type: 'allocation' },
                        { from: 'resource2', to: 'process2', type: 'allocation' },
                        { from: 'process1', to: 'resource2', type: 'request' }
                    ]
                },
                { 
                    message: "P2 requests 1 unit from R1 - Deadlock!", 
                    arrows: [
                        { from: 'resource1', to: 'process1', type: 'allocation' },
                        { from: 'resource2', to: 'process2', type: 'allocation' },
                        { from: 'process1', to: 'resource2', type: 'request' },
                        { from: 'process2', to: 'resource1', type: 'request' }
                    ],
                    highlight: ['process1', 'process2', 'resource1', 'resource2']
                },
                { 
                    message: "Reset simulation", 
                    reset: true
                }
            ];
            
            // Initial message
            message.textContent = states[0].message;
            
            allocateBtn.addEventListener('click', () => {
                state = (state + 1) % states.length;
                const currentState = states[state];
                
                // Update message
                message.textContent = currentState.message;
                
                // Reset if needed
                if (currentState.reset) {
                    arrowsContainer.innerHTML = '';
                    document.querySelectorAll('.resource-unit').forEach(unit => {
                        unit.classList.remove('allocated');
                    });
                    document.querySelectorAll('.process-block, .resource-block').forEach(block => {
                        block.classList.remove('highlight-element');
                    });
                    state = 0;
                    message.textContent = states[0].message;
                    return;
                }
                
                // Clear previous arrows
                arrowsContainer.innerHTML = '';
                
                // Remove previous highlights
                document.querySelectorAll('.process-block, .resource-block').forEach(block => {
                    block.classList.remove('highlight-element');
                });
                
                // Add new arrows
                if (currentState.arrows) {
                    currentState.arrows.forEach(arrow => {
                        createArrow(arrow.from, arrow.to, arrow.type);
                    });
                }
                
                // Allocate resource unit if specified
                if (currentState.allocate) {
                    const { resource, unit } = currentState.allocate;
                    const resourceEl = document.getElementById(resource);
                    const units = resourceEl.querySelectorAll('.resource-unit');
                    if (units[unit]) {
                        units[unit].classList.add('allocated');
                    }
                }
                
                // Highlight elements if specified
                if (currentState.highlight) {
                    currentState.highlight.forEach(id => {
                        const element = document.getElementById(id);
                        if (element) {
                            element.classList.add('highlight-element');
                        }
                    });
                }
            });
            
            // Helper function to create arrows
            function createArrow(fromId, toId, type) {
                const from = document.getElementById(fromId);
                const to = document.getElementById(toId);
                
                if (!from || !to) return;
                
                const fromRect = from.getBoundingClientRect();
                const toRect = to.getBoundingClientRect();
                const containerRect = arrowsContainer.getBoundingClientRect();
                
                // Get center points relative to the container
                const fromX = fromRect.left + fromRect.width/2 - containerRect.left;
                const fromY = fromRect.top + fromRect.height/2 - containerRect.top;
                const toX = toRect.left + toRect.width/2 - containerRect.left;
                const toY = toRect.top + toRect.height/2 - containerRect.top;
                
                // Calculate distance and angle
                const distance = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                
                // Create arrow
                const arrow = document.createElement('div');
                arrow.className = `allocation-arrow ${type === 'request' ? 'request-arrow' : ''}`;
                arrow.style.width = `${distance}px`;
                arrow.style.left = `${fromX}px`;
                arrow.style.top = `${fromY}px`;
                arrow.style.transform = `rotate(${angle}deg)`;
                
                arrowsContainer.appendChild(arrow);
                
                // Add entrance animation
                arrow.animate([
                    { width: '0px', opacity: 0 },
                    { width: `${distance}px`, opacity: 1 }
                ], {
                    duration: 500,
                    easing: 'ease-out'
                });
                
                return arrow;
            }
        }
        
        // Initialize Process State Visualization
        function initProcessVisualization() {
            const stateElements = document.querySelectorAll('.process-state');
            const transitionsContainer = document.querySelector('.state-transitions');
            
            if (!stateElements.length || !transitionsContainer) return;
            
            // Define state transitions
            const transitions = [
                { from: 'new', to: 'ready' },
                { from: 'ready', to: 'running' },
                { from: 'running', to: 'terminated' },
                { from: 'running', to: 'ready' },
                { from: 'running', to: 'blocked' },
                { from: 'blocked', to: 'ready' }
            ];
            
            // Create transition arrows
            setTimeout(() => {
                transitions.forEach(transition => {
                    const fromElement = document.querySelector(`.process-state[data-state="${transition.from}"]`);
                    const toElement = document.querySelector(`.process-state[data-state="${transition.to}"]`);
                    
                    if (fromElement && toElement) {
                        createTransitionArrow(fromElement, toElement, transition);
                    }
                });
            }, 500); // Delay to ensure elements are positioned
            
            // Add hover effect for states to highlight transitions
            stateElements.forEach(state => {
                state.addEventListener('mouseenter', () => {
                    const currentState = state.getAttribute('data-state');
                    
                    // Find only transitions that originate FROM the current state 
                    // (only outgoing transitions, not incoming)
                    const validTransitions = transitions.filter(
                        t => t.from === currentState
                    );
                    
                    // Highlight only valid outgoing transitions
                    validTransitions.forEach(transition => {
                        const arrow = document.querySelector(
                            `.transition-arrow[data-from="${transition.from}"][data-to="${transition.to}"]`
                        );
                        if (arrow) {
                            arrow.classList.add('highlight');
                        }
                    });
                    
                    // Add active state to current state
                    state.classList.add('active');
                });
                
                state.addEventListener('mouseleave', () => {
                    // Remove all highlights
                    document.querySelectorAll('.transition-arrow').forEach(arrow => {
                        arrow.classList.remove('highlight');
                    });
                    
                    // Remove active state from all states
                    document.querySelectorAll('.process-state').forEach(s => {
                        s.classList.remove('active');
                    });
                });
            });
            
            // Helper function to create transition arrows
            function createTransitionArrow(fromElement, toElement, transition) {
                const fromRect = fromElement.getBoundingClientRect();
                const toRect = toElement.getBoundingClientRect();
                const containerRect = transitionsContainer.getBoundingClientRect();
                
                // Calculate positions relative to the container
                const fromX = fromRect.left + fromRect.width/2 - containerRect.left;
                const fromY = fromRect.top + fromRect.height/2 - containerRect.top;
                const toX = toRect.left + toRect.width/2 - containerRect.left;
                const toY = toRect.top + toRect.height/2 - containerRect.top;
                
                // Calculate angle and distance
                const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                const distance = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                
                // Create arrow element
                const arrow = document.createElement('div');
                arrow.className = 'transition-arrow';
                arrow.style.width = `${distance}px`;
                arrow.style.left = `${fromX}px`;
                arrow.style.top = `${fromY}px`;
                arrow.style.transform = `rotate(${angle}deg)`;
                
                // Set data attributes for state identification
                arrow.setAttribute('data-from', transition.from);
                arrow.setAttribute('data-to', transition.to);
                
                // Add arrow to container
                transitionsContainer.appendChild(arrow);
                
                // Add entrance animation
                arrow.animate([
                    { width: '0px', opacity: 0 },
                    { width: `${distance}px`, opacity: 0.5 }
                ], {
                    duration: 600,
                    easing: 'ease-out'
                });
                
                return arrow;
            }
        }
        
        // Initialize Process Simulator
        function initProcessSimulator() {
            const createBtn = document.getElementById('createProcessBtn');
            const blockBtn = document.getElementById('blockProcessBtn');
            const unblockBtn = document.getElementById('unblockProcessBtn');
            const terminateBtn = document.getElementById('terminateProcessBtn');
            const messageEl = document.getElementById('processMessage');
            const createdCountEl = document.getElementById('createdCount');
            const runningCountEl = document.getElementById('runningCount');
            const blockedCountEl = document.getElementById('blockedCount');
            const terminatedCountEl = document.getElementById('terminatedCount');
            
            if (!createBtn) return;
            
            // Initial state
            let processes = [];
            let processCounter = 0;
            let runningProcess = null;
            let stats = {
                created: 0,
                running: 0,
                blocked: 0,
                terminated: 0
            };
            
            // Disable buttons initially
            blockBtn.disabled = true;
            unblockBtn.disabled = true;
            terminateBtn.disabled = true;
            
            // Create process handler
            createBtn.addEventListener('click', () => {
                processCounter++;
                const process = {
                    id: processCounter,
                    state: 'ready'
                };
                
                processes.push(process);
                stats.created++;
                updateStats();
                
                // Add to ready queue
                const emptySlot = document.querySelector('.ready-slot:empty');
                if (emptySlot) {
                    const processEl = createProcessElement(process);
                    emptySlot.appendChild(processEl);
                    
                    // Show message
                    messageEl.textContent = `Process P${process.id} created and added to ready queue`;
                    
                    // Automatically run if no process is running
                    if (!runningProcess) {
                        setTimeout(() => {
                            moveToRunning(process);
                        }, 1000);
                    }
                } else {
                    messageEl.textContent = `Ready queue is full! Cannot add P${process.id}`;
                }
                
                // Update button states
                updateButtonStates();
            });
            
            // Block process handler
            blockBtn.addEventListener('click', () => {
                if (runningProcess) {
                    blockProcess(runningProcess);
                }
            });
            
            // Unblock process handler
            unblockBtn.addEventListener('click', () => {
                // Find first blocked process
                const blockedSlot = document.querySelector('.blocked-slot .process-circle');
                if (blockedSlot) {
                    const processId = parseInt(blockedSlot.getAttribute('data-pid'));
                    const process = processes.find(p => p.id === processId);
                    if (process) {
                        unblockProcess(process);
                    }
                }
            });
            
            // Terminate process handler
            terminateBtn.addEventListener('click', () => {
                if (runningProcess) {
                    terminateProcess(runningProcess);
                }
            });
            
            // Block a process
            function blockProcess(process) {
                const emptyBlockedSlot = document.querySelector('.blocked-slot:empty');
                if (emptyBlockedSlot && runningProcess) {
                    // Update process state
                    process.state = 'blocked';
                    
                    // Update stats
                    stats.running--;
                    stats.blocked++;
                    updateStats();
                    
                    // Remove from CPU
                    const processCpu = document.querySelector('.cpu-core .process-circle');
                    if (processCpu) {
                        animateProcessMovement(processCpu, emptyBlockedSlot);
                        
                        setTimeout(() => {
                            const newProcessEl = createProcessElement(process);
                            emptyBlockedSlot.appendChild(newProcessEl);
                            processCpu.remove();
                            
                            // Update message
                            messageEl.textContent = `Process P${process.id} blocked, waiting for resources`;
                            
                            // Clear running process
                            runningProcess = null;
                            
                            // Move next ready process to CPU if any
                            setTimeout(moveNextReadyToCpu, 800);
                        }, 500);
                    }
                } else {
                    messageEl.textContent = "Can't block process: Blocked queue is full or no running process";
                }
                
                // Update button states
                updateButtonStates();
            }
            
            // Unblock a process
            function unblockProcess(process) {
                const emptyReadySlot = document.querySelector('.ready-slot:empty');
                if (emptyReadySlot) {
                    // Update process state
                    process.state = 'ready';
                    
                    // Update stats
                    stats.blocked--;
                    updateStats();
                    
                    // Find process element in blocked queue
                    const processEl = document.querySelector(`.blocked-slot .process-circle[data-pid="${process.id}"]`);
                    if (processEl) {
                        const parentSlot = processEl.parentElement;
                        
                        // Animate movement to ready queue
                        animateProcessMovement(processEl, emptyReadySlot);
                        
                        setTimeout(() => {
                            const newProcessEl = createProcessElement(process);
                            emptyReadySlot.appendChild(newProcessEl);
                            processEl.remove();
                            
                            // Update message
                            messageEl.textContent = `Process P${process.id} unblocked, moved to ready queue`;
                            
                            // If no running process, move this one to CPU
                            if (!runningProcess) {
                                setTimeout(() => moveToRunning(process), 800);
                            }
                        }, 500);
                    }
                } else {
                    messageEl.textContent = "Can't unblock process: Ready queue is full";
                }
                
                // Update button states
                updateButtonStates();
            }
            
            // Move process to running state
            function moveToRunning(process) {
                if (runningProcess) return;
                
                // Update process state
                process.state = 'running';
                runningProcess = process;
                
                // Update stats
                stats.running++;
                updateStats();
                
                // Find process element in ready queue
                const processEl = document.querySelector(`.ready-slot .process-circle[data-pid="${process.id}"]`);
                if (processEl) {
                    const parentSlot = processEl.parentElement;
                    const cpuCore = document.querySelector('.cpu-core');
                    
                    // Animate movement to CPU
                    animateProcessMovement(processEl, cpuCore);
                    
                    setTimeout(() => {
                        const newProcessEl = createProcessElement(process);
                        cpuCore.appendChild(newProcessEl);
                        processEl.remove();
                        
                        // Update message
                        messageEl.textContent = `Process P${process.id} is now running on CPU`;
                    }, 500);
                }
                
                // Update button states
                updateButtonStates();
            }
            
            // Terminate a process
            function terminateProcess(process) {
                if (runningProcess) {
                    // Update process state
                    process.state = 'terminated';
                    
                    // Update stats
                    stats.running--;
                    stats.terminated++;
                    updateStats();
                    
                    // Remove from processes array
                    processes = processes.filter(p => p.id !== process.id);
                    
                    // Find process element in CPU
                    const processEl = document.querySelector(`.cpu-core .process-circle[data-pid="${process.id}"]`);
                    if (processEl) {
                        // Create termination animation
                        processEl.style.animation = 'none';
                        processEl.offsetHeight; // Trigger reflow
                        processEl.style.animation = 'fadeOut 0.5s forwards';
                        
                        setTimeout(() => {
                            processEl.remove();
                            
                            // Update message
                            messageEl.textContent = `Process P${process.id} terminated`;
                            
                            // Clear running process
                            runningProcess = null;
                            
                            // Move next ready process to CPU if any
                            setTimeout(moveNextReadyToCpu, 800);
                        }, 500);
                    }
                }
                
                // Update button states
                updateButtonStates();
            }
            
            // Move next ready process to CPU
            function moveNextReadyToCpu() {
                const readyProcessEl = document.querySelector('.ready-slot .process-circle');
                if (readyProcessEl) {
                    const processId = parseInt(readyProcessEl.getAttribute('data-pid'));
                    const process = processes.find(p => p.id === processId);
                    if (process) {
                        moveToRunning(process);
                    }
                }
            }
            
            // Create a process element
            function createProcessElement(process) {
                const processEl = document.createElement('div');
                processEl.className = 'process-circle';
                processEl.textContent = `P${process.id}`;
                processEl.setAttribute('data-pid', process.id);
                
                // Apply high contrast styling if necessary
                const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                const isLightTheme = document.documentElement.getAttribute('data-theme') !== 'dark';
                
                if (isHighContrast) {
                    processEl.style.background = isLightTheme ? '#000000' : '#ffffff';
                    processEl.style.color = isLightTheme ? '#ffffff' : '#000000';
                    processEl.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                }
                
                return processEl;
            }
            
            // Animate process movement
            function animateProcessMovement(processEl, targetEl) {
                const processRect = processEl.getBoundingClientRect();
                const targetRect = targetEl.getBoundingClientRect();
                const flyingProcess = processEl.cloneNode(true);
                
                // Position the flying process at the start position
                document.body.appendChild(flyingProcess);
                flyingProcess.style.position = 'fixed';
                flyingProcess.style.top = `${processRect.top}px`;
                flyingProcess.style.left = `${processRect.left}px`;
                flyingProcess.style.zIndex = 1000;
                
                // Calculate the flight path
                const flyX = targetRect.left - processRect.left;
                const flyY = targetRect.top - processRect.top;
                
                // Add flying animation
                flyingProcess.style.setProperty('--fly-x', `${flyX}px`);
                flyingProcess.style.setProperty('--fly-y', `${flyY}px`);
                flyingProcess.classList.add('flying-process');
                
                // Remove the flying element after animation completes
                setTimeout(() => {
                    flyingProcess.remove();
                }, 500);
            }
            
            // Update stats display
            function updateStats() {
                createdCountEl.textContent = stats.created;
                runningCountEl.textContent = stats.running;
                blockedCountEl.textContent = stats.blocked;
                terminatedCountEl.textContent = stats.terminated;
            }
            
            // Update button states based on current system state
            function updateButtonStates() {
                blockBtn.disabled = !runningProcess;
                terminateBtn.disabled = !runningProcess;
                
                // Check if there are any blocked processes
                const hasBlockedProcesses = document.querySelector('.blocked-slot .process-circle') !== null;
                unblockBtn.disabled = !hasBlockedProcesses;
                
                // Disable create if ready queue is full
                const readyQueueFull = document.querySelector('.ready-slot:empty') === null;
                createBtn.disabled = readyQueueFull && !runningProcess;
            }
            
            // Add keyframes for process animations
            const styleSheet = document.createElement('style');
            styleSheet.textContent = `
                @keyframes fadeOut {
                    0% { transform: scale(1); opacity: 1; }
                    50% { transform: scale(1.2); opacity: 0.7; }
                    100% { transform: scale(0); opacity: 0; }
                }
            `;
            document.head.appendChild(styleSheet);
        }
        
        // Call initialization functions after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing initialization code ...
            
            // Initialize Process State Visualization and Simulator
            initProcessVisualization();
            initProcessSimulator();
            
            // Initialize Resource Allocation Graph
            initResourceAllocationGraph();
            
            // Fix resource card flipping on mobile
            initMobileResourceCards();
        });
        
        // Initialize the Resource Allocation Graph interactive visualization
        function initResourceAllocationGraph() {
            const canvas = document.getElementById('ragCanvas');
            if (!canvas) return;
            
            const addProcessBtn = document.getElementById('addProcessBtn');
            const addResourceBtn = document.getElementById('addResourceBtn');
            const createAllocationBtn = document.getElementById('createAllocationBtn');
            const createRequestBtn = document.getElementById('createRequestBtn');
            const detectDeadlockBtn = document.getElementById('detectDeadlockBtn');
            const clearGraphBtn = document.getElementById('clearGraphBtn');
            const messageEl = document.getElementById('ragMessage');
            
            let nodes = [];
            let edges = [];
            let processCounter = 0;
            let resourceCounter = 0;
            let selectedNode = null;
            let isDragging = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            
            // Disable edge creation buttons initially
            createAllocationBtn.disabled = true;
            createRequestBtn.disabled = true;
            
            // Add a process node to the canvas
            addProcessBtn.addEventListener('click', () => {
                processCounter++;
                const processId = processCounter;
                const x = 50 + Math.random() * (canvas.clientWidth - 150);
                const y = 50 + Math.random() * (canvas.clientHeight - 150);
                
                const node = createNode('process', `P${processId}`, x, y);
                nodes.push({ id: `P${processId}`, type: 'process', element: node, x, y });
                canvas.appendChild(node);
                
                messageEl.textContent = `Process P${processId} added`;
                clearGraphBtn.disabled = false;
            });
            
            // Add a resource node to the canvas
            addResourceBtn.addEventListener('click', () => {
                resourceCounter++;
                const resourceId = resourceCounter;
                const x = 50 + Math.random() * (canvas.clientWidth - 150);
                const y = 50 + Math.random() * (canvas.clientHeight - 150);
                
                const node = createNode('resource', `R${resourceId}`, x, y);
                nodes.push({ id: `R${resourceId}`, type: 'resource', element: node, x, y });
                canvas.appendChild(node);
                
                messageEl.textContent = `Resource R${resourceId} added`;
                clearGraphBtn.disabled = false;
            });
            
            // Create an allocation edge (resource to process)
            createAllocationBtn.addEventListener('click', () => {
                if (selectedNode && selectedNode.type === 'resource') {
                    // Show selection UI for processes
                    const processes = nodes.filter(node => node.type === 'process');
                    if (processes.length === 0) {
                        messageEl.textContent = "No processes available to allocate to.";
                        return;
                    }
                    
                    // Flash available process nodes to indicate they can be selected
                    processes.forEach(process => {
                        process.element.classList.add('flash-node');
                        setTimeout(() => {
                            process.element.classList.remove('flash-node');
                        }, 1500);
                    });
                    
                    messageEl.textContent = "Click on a process to create allocation.";
                }
            });
            
            // Create a request edge (process to resource)
            createRequestBtn.addEventListener('click', () => {
                if (selectedNode && selectedNode.type === 'process') {
                    // Show selection UI for resources
                    const resources = nodes.filter(node => node.type === 'resource');
                    if (resources.length === 0) {
                        messageEl.textContent = "No resources available to request.";
                        return;
                    }
                    
                    // Flash available resource nodes to indicate they can be selected
                    resources.forEach(resource => {
                        resource.element.classList.add('flash-node');
                        setTimeout(() => {
                            resource.element.classList.remove('flash-node');
                        }, 1500);
                    });
                    
                    messageEl.textContent = "Click on a resource to create request.";
                }
            });
            
            // Detect deadlocks in the graph
            detectDeadlockBtn.addEventListener('click', () => {
                // Remove any previous deadlock highlighting
                edges.forEach(edge => {
                    edge.element.classList.remove('deadlock');
                });
                
                // Find cycles in the graph (improved algorithm for better deadlock detection)
                const deadlockEdges = findDeadlockCycle();
                if (deadlockEdges.length > 0) {
                    // Highlight deadlock edges
                    deadlockEdges.forEach(edgeId => {
                        const edge = edges.find(e => e.id === edgeId);
                        if (edge) {
                            edge.element.classList.add('deadlock');
                        }
                    });
                    
                    messageEl.textContent = "Deadlock detected! A cycle has been found in the graph.";
                } else {
                    messageEl.textContent = "No deadlock detected in the current graph.";
                }
            });
            
            // Clear all nodes and edges from the graph
            clearGraphBtn.addEventListener('click', () => {
                // Remove all edges and nodes from the DOM
                edges.forEach(edge => {
                    edge.element.remove();
                });
                nodes.forEach(node => {
                    node.element.remove();
                });
                
                // Reset arrays and counters
                nodes = [];
                edges = [];
                processCounter = 0;
                resourceCounter = 0;
                selectedNode = null;
                
                // Update message
                messageEl.textContent = "Graph cleared. Add processes and resources to begin.";
                
                // Disable buttons
                createAllocationBtn.disabled = true;
                createRequestBtn.disabled = true;
                detectDeadlockBtn.disabled = true;
                clearGraphBtn.disabled = true;
            });
            
            // Handle node selection and dragging
            canvas.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // Create a node element
            function createNode(type, id, x, y) {
                const node = document.createElement('div');
                node.className = `rag-node rag-${type}`;
                node.textContent = id;
                node.dataset.id = id;
                node.dataset.type = type;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                // Apply high contrast styling if necessary
                const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                const isLightTheme = document.documentElement.getAttribute('data-theme') !== 'dark';
                
                if (isHighContrast) {
                    if (type === 'process') {
                        node.style.background = isLightTheme ? '#000000' : '#ffffff';
                        node.style.color = isLightTheme ? '#ffffff' : '#000000';
                        node.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                    } else { // resource
                        node.style.background = isLightTheme ? '#000000' : '#ffffff';
                        node.style.color = isLightTheme ? '#ffffff' : '#000000';
                        node.style.border = isLightTheme ? '2px solid #ffffff' : '2px solid #000000';
                    }
                }
                
                return node;
            }
            
            // Create an edge between nodes
            function createEdge(fromNode, toNode, type) {
                // Calculate the edge id to prevent duplicate edges
                const edgeId = `${fromNode.dataset.id}-${toNode.dataset.id}`;
                
                // Check if the edge already exists
                if (edges.some(e => e.id === edgeId)) {
                    messageEl.textContent = "This connection already exists.";
                    return null;
                }
                
                // Get positions
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate center points relative to the canvas
                const fromX = fromRect.left + fromRect.width/2 - canvasRect.left;
                const fromY = fromRect.top + fromRect.height/2 - canvasRect.top;
                const toX = toRect.left + toRect.width/2 - canvasRect.left;
                const toY = toRect.top + toRect.height/2 - canvasRect.top;
                
                // Calculate angle, distance and node radii
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const distance = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                
                // Determine the radius for each node type
                const fromRadius = fromNode.classList.contains('rag-process') ? 27.5 : 25;
                const toRadius = toNode.classList.contains('rag-process') ? 27.5 : 25;
                
                // Adjust start and end points to be at the edge of the nodes
                const buffer = 5; // Extra space to prevent visual overlap
                const adjustedFromX = fromX + (fromRadius + buffer) * Math.cos(angle);
                const adjustedFromY = fromY + (fromRadius + buffer) * Math.sin(angle);
                const adjustedToX = toX - (toRadius + buffer) * Math.cos(angle);
                const adjustedToY = toY - (toRadius + buffer) * Math.sin(angle);
                
                // Calculate the new distance between the adjusted points
                const adjustedDistance = Math.sqrt(
                    Math.pow(adjustedToX - adjustedFromX, 2) + 
                    Math.pow(adjustedToY - adjustedFromY, 2)
                );
                
                // Create the edge element
                const edge = document.createElement('div');
                edge.className = `rag-edge ${type}`;
                edge.dataset.from = fromNode.dataset.id;
                edge.dataset.to = toNode.dataset.id;
                edge.style.width = `${adjustedDistance}px`;
                edge.style.left = `${adjustedFromX}px`;
                edge.style.top = `${adjustedFromY}px`;
                edge.style.transform = `rotate(${angle}rad)`;
                
                // Add the edge to the DOM and the edges array
                canvas.appendChild(edge);
                
                // Add to edges array for tracking
                edges.push({
                    id: edgeId,
                    from: fromNode.dataset.id,
                    to: toNode.dataset.id,
                    type: type,
                    element: edge
                });
                
                // Enable deadlock detection
                detectDeadlockBtn.disabled = false;
                
                return edge;
            }
            
            // Mouse event handlers
            function handleMouseDown(e) {
                const target = e.target;
                if (target.classList.contains('rag-node')) {
                    // Deselect previous node
                    if (selectedNode) {
                        selectedNode.element.classList.remove('selected');
                    }
                    
                    // Handle node selection
                    const nodeId = target.dataset.id;
                    const nodeType = target.dataset.type;
                    const node = nodes.find(n => n.id === nodeId);
                    
                    if (node) {
                        // If we already have a selected node of a different type,
                        // create an edge between them
                        if (selectedNode && selectedNode.type !== nodeType) {
                            let fromNode, toNode, edgeType;
                            
                            if (selectedNode.type === 'process' && nodeType === 'resource') {
                                // Process requesting a resource
                                fromNode = selectedNode.element;
                                toNode = target;
                                edgeType = 'request';
                                messageEl.textContent = `Process ${selectedNode.id} is requesting Resource ${nodeId}`;
                            } else if (selectedNode.type === 'resource' && nodeType === 'process') {
                                // Resource allocated to a process
                                fromNode = selectedNode.element;
                                toNode = target;
                                edgeType = 'allocation';
                                messageEl.textContent = `Resource ${selectedNode.id} is allocated to Process ${nodeId}`;
                            }
                            
                            if (fromNode && toNode) {
                                createEdge(fromNode, toNode, edgeType);
                            }
                            
                            // Deselect after creating an edge
                            selectedNode.element.classList.remove('selected');
                            selectedNode = null;
                            
                            // Update button states
                            updateButtonStates();
                            
                            return;
                        }
                        
                        // Select the node
                        selectedNode = node;
                        target.classList.add('selected');
                        
                        // Update button states based on selection
                        updateButtonStates();
                        
                        // Prepare for dragging
                        isDragging = true;
                        const rect = target.getBoundingClientRect();
                        dragOffsetX = e.clientX - rect.left;
                        dragOffsetY = e.clientY - rect.top;
                        
                        messageEl.textContent = `${nodeType === 'process' ? 'Process' : 'Resource'} ${nodeId} selected`;
                    }
                } else if (target === canvas) {
                    // Deselect when clicking on empty canvas
                    if (selectedNode) {
                        selectedNode.element.classList.remove('selected');
                        selectedNode = null;
                        updateButtonStates();
                    }
                }
            }
            
            function handleMouseMove(e) {
                if (isDragging && selectedNode) {
                    // Calculate new position relative to canvas
                    const canvasRect = canvas.getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - dragOffsetX;
                    const y = e.clientY - canvasRect.top - dragOffsetY;
                    
                    // Restrict to canvas boundaries with 25px margin
                    const maxX = canvas.clientWidth - 50;
                    const maxY = canvas.clientHeight - 50;
                    const boundedX = Math.max(25, Math.min(maxX, x));
                    const boundedY = Math.max(25, Math.min(maxY, y));
                    
                    // Update node position
                    selectedNode.element.style.left = `${boundedX}px`;
                    selectedNode.element.style.top = `${boundedY}px`;
                    
                    // Update node's stored position
                    selectedNode.x = boundedX;
                    selectedNode.y = boundedY;
                    
                    // Update all edges connected to this node
                    updateConnectedEdges(selectedNode.id);
                }
            }
            
            function handleMouseUp() {
                isDragging = false;
            }
            
            // Update the position of all edges connected to a node
            function updateConnectedEdges(nodeId) {
                // Find all edges connected to this node
                const connectedEdges = edges.filter(
                    edge => edge.from === nodeId || edge.to === nodeId
                );
                
                connectedEdges.forEach(edge => {
                    // Find the source and target nodes
                    const fromNode = nodes.find(node => node.id === edge.from).element;
                    const toNode = nodes.find(node => node.id === edge.to).element;
                    
                    // Get positions
                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    // Calculate center points relative to the canvas
                    const fromX = fromRect.left + fromRect.width/2 - canvasRect.left;
                    const fromY = fromRect.top + fromRect.height/2 - canvasRect.top;
                    const toX = toRect.left + toRect.width/2 - canvasRect.left;
                    const toY = toRect.top + toRect.height/2 - canvasRect.top;
                    
                    // Calculate angle, distance and node radii
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    const distance = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                    
                    // Determine the radius for each node type
                    const fromRadius = fromNode.classList.contains('rag-process') ? 27.5 : 25;
                    const toRadius = toNode.classList.contains('rag-process') ? 27.5 : 25;
                    
                    // Adjust start and end points to be at the edge of the nodes
                    const buffer = 5; // Extra space to prevent visual overlap
                    const adjustedFromX = fromX + (fromRadius + buffer) * Math.cos(angle);
                    const adjustedFromY = fromY + (fromRadius + buffer) * Math.sin(angle);
                    const adjustedToX = toX - (toRadius + buffer) * Math.cos(angle);
                    const adjustedToY = toY - (toRadius + buffer) * Math.sin(angle);
                    
                    // Calculate the new distance between the adjusted points
                    const adjustedDistance = Math.sqrt(
                        Math.pow(adjustedToX - adjustedFromX, 2) + 
                        Math.pow(adjustedToY - adjustedFromY, 2)
                    );
                    
                    // Update the edge position
                    edge.element.style.width = `${adjustedDistance}px`;
                    edge.element.style.left = `${adjustedFromX}px`;
                    edge.element.style.top = `${adjustedFromY}px`;
                    edge.element.style.transform = `rotate(${angle}rad)`;
                });
            }
            
            // Find cycles in the graph (improved algorithm for better deadlock detection)
            function findDeadlockCycle() {
                // Build an adjacency list representation of the graph
                const adjacencyList = {};
                
                // Initialize adjacency list for all nodes
                nodes.forEach(node => {
                    adjacencyList[node.id] = [];
                });
                
                // Populate the adjacency list based on edges
                edges.forEach(edge => {
                    // For resource allocation graphs, we need to consider:
                    // 1. Request edges: Process -> Resource
                    // 2. Allocation edges: Resource -> Process
                    // A deadlock cycle occurs when there's a cycle in the graph
                    adjacencyList[edge.from].push(edge.to);
                });
                
                // DFS-based cycle detection
                const visited = new Set();
                const recursionStack = new Set();
                const cycleEdges = [];
                
                function dfs(nodeId, path = []) {
                    // Mark current node as visited and add to recursion stack
                    visited.add(nodeId);
                    recursionStack.add(nodeId);
                    
                    // Visit all adjacent nodes
                    for (const neighborId of adjacencyList[nodeId] || []) {
                        // If not visited, recursively visit
                        if (!visited.has(neighborId)) {
                            const result = dfs(neighborId, [...path, { from: nodeId, to: neighborId }]);
                            if (result.length > 0) {
                                // Cycle found in deeper recursion
                                return result;
                            }
                        } 
                        // If already in recursion stack, we found a cycle
                        else if (recursionStack.has(neighborId)) {
                            // Find the edge IDs forming the cycle
                            const cycleStart = path.findIndex(edge => edge.to === neighborId);
                            if (cycleStart !== -1) {
                                const cyclePath = path.slice(cycleStart);
                                cyclePath.push({ from: nodeId, to: neighborId });
                                
                                // Convert path edges to edge IDs
                                return cyclePath.map(pathEdge => {
                                    const edge = edges.find(e => 
                                        e.from === pathEdge.from && e.to === pathEdge.to);
                                    return edge ? edge.id : null;
                                }).filter(id => id !== null);
                            }
                        }
                    }
                    
                    // Remove from recursion stack when backtracking
                    recursionStack.delete(nodeId);
                    return [];
                }
                
                // Check for cycles starting from each node
                for (const node of nodes) {
                    if (!visited.has(node.id)) {
                        const result = dfs(node.id);
                        if (result.length > 0) {
                            // We found a cycle
                            return result;
                        }
                    }
                }
                
                // Special case: check for direct cycles between processes and resources
                // (this covers the case where a process requests a resource allocated to another process)
                edges.forEach(edge1 => {
                    if (edge1.type === 'request') {
                        // Check for a reverse path from resource back to this process
                        const processId = edge1.from;
                        const resourceId = edge1.to;
                        
                        // Find allocations of this resource
                        const allocations = edges.filter(e => 
                            e.type === 'allocation' && e.from === resourceId);
                        
                        for (const allocation of allocations) {
                            const otherProcessId = allocation.to;
                            if (otherProcessId !== processId) {
                                // Check if this other process requests resources held by our original process
                                const reverseRequest = edges.find(e => 
                                    e.type === 'request' && 
                                    e.from === otherProcessId && 
                                    e.to !== resourceId);
                                
                                if (reverseRequest) {
                                    const reverseAllocation = edges.find(e => 
                                        e.type === 'allocation' && 
                                        e.from === reverseRequest.to && 
                                        e.to === processId);
                                    
                                    if (reverseAllocation) {
                                        // We found a deadlock cycle
                                        return [edge1.id, allocation.id, reverseRequest.id, reverseAllocation.id];
                                    }
                                }
                            }
                        }
                    }
                });
                
                return [];
            }
            
            // Update button states based on selection
            function updateButtonStates() {
                if (selectedNode) {
                    if (selectedNode.type === 'process') {
                        createRequestBtn.disabled = false;
                        createAllocationBtn.disabled = true;
                    } else if (selectedNode.type === 'resource') {
                        createRequestBtn.disabled = true;
                        createAllocationBtn.disabled = false;
                    }
                } else {
                    createRequestBtn.disabled = true;
                    createAllocationBtn.disabled = true;
                }
            }
            
            // Add some initial nodes for example
            setTimeout(() => {
                // Add a couple of processes and resources
                addProcessBtn.click();
                addProcessBtn.click();
                addResourceBtn.click();
                addResourceBtn.click();
                
                // Position them in a meaningful layout
                if (nodes.length >= 4) {
                    nodes[0].element.style.left = '100px';
                    nodes[0].element.style.top = '100px';
                    nodes[0].x = 100;
                    nodes[0].y = 100;
                    
                    nodes[1].element.style.left = '300px';
                    nodes[1].element.style.top = '100px';
                    nodes[1].x = 300;
                    nodes[1].y = 100;
                    
                    nodes[2].element.style.left = '100px';
                    nodes[2].element.style.top = '250px';
                    nodes[2].x = 100;
                    nodes[2].y = 250;
                    
                    nodes[3].element.style.left = '300px';
                    nodes[3].element.style.top = '250px';
                    nodes[3].x = 300;
                    nodes[3].y = 250;
                }
                
                messageEl.textContent = "Example graph created. Try adding edges between nodes!";
            }, 500);
        }
        
        // Handle resource card flipping on mobile without layout shifts
        function initMobileResourceCards() {
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (isTouchDevice) {
                // Mark the body as a mobile device to apply CSS optimizations
                document.body.classList.add('mobile-device');
                
                // Update card hints to show "Tap for details" instead of "Hover for details"
                const cardHints = document.querySelectorAll('.card-hover-hint');
                cardHints.forEach(hint => {
                    hint.textContent = "Tap for details";
                });
                
                // Inject additional style for better card appearance
                const styleElement = document.createElement('style');
                styleElement.textContent = `
                    .mobile-device .resource-3d-card {
                        height: 220px !important;
                    }
                    
                    .mobile-device .resource-3d-card .resource-card-front,
                    .mobile-device .resource-3d-card .resource-card-back {
                        padding: 16px !important;
                        display: flex !important;
                        flex-direction: column !important;
                        justify-content: center !important;
                        align-items: center !important;
                        text-align: center !important;
                        box-sizing: border-box !important;
                        width: 100% !important;
                        height: 100% !important;
                    }
                    
                    .mobile-device .resource-3d-card .resource-examples {
                        margin-top: 15px !important;
                        display: flex !important;
                        flex-wrap: wrap !important;
                        gap: 4px !important;
                        justify-content: center !important;
                        width: 100% !important;
                    }
                `;
                document.head.appendChild(styleElement);
                
                // Get all resource cards
                const resourceCards = document.querySelectorAll('.resource-3d-card');
                let lastTapped = null;
                
                // Add IDs to cards if missing
                resourceCards.forEach((card, index) => {
                    if (!card.id) {
                        card.id = `resource-card-${index}`;
                    }
                    
                    // Standardize all card layouts
                    const cardFront = card.querySelector('.resource-card-front');
                    const cardBack = card.querySelector('.resource-card-back');
                    
                    if (cardFront && cardBack) {
                        // Set consistent layout for front
                        cardFront.style.display = 'flex';
                        cardFront.style.flexDirection = 'column';
                        cardFront.style.justifyContent = 'center';
                        cardFront.style.alignItems = 'center';
                        cardFront.style.textAlign = 'center';
                        cardFront.style.width = '100%';
                        cardFront.style.height = '100%';
                        cardFront.style.padding = '16px';
                        cardFront.style.boxSizing = 'border-box';
                        
                        // Set consistent layout for back
                        cardBack.style.display = 'flex';
                        cardBack.style.flexDirection = 'column';
                        cardBack.style.justifyContent = 'center';
                        cardBack.style.alignItems = 'center';
                        cardBack.style.textAlign = 'center';
                        cardBack.style.width = '100%';
                        cardBack.style.height = '100%';
                        cardBack.style.padding = '16px';
                        cardBack.style.boxSizing = 'border-box';
                        
                        // Fix card icon sizing
                        const icon = cardFront.querySelector('.resource-icon');
                        if (icon) {
                            icon.style.width = '40px';
                            icon.style.height = '40px';
                            icon.style.marginBottom = '10px';
                            icon.style.marginTop = '8px';
                        }
                        
                        // Fix card title sizing
                        const title = cardFront.querySelector('h3');
                        if (title) {
                            title.style.fontSize = '1rem';
                            title.style.margin = '0 0 8px 0';
                            title.style.lineHeight = '1.3';
                        }
                        
                        // Fix card description sizing
                        const description = cardBack.querySelector('p');
                        if (description) {
                            description.style.fontSize = '0.85rem';
                            description.style.lineHeight = '1.4';
                            description.style.margin = '0 0 12px 0';
                            description.style.maxWidth = '90%';
                        }
                        
                        // Fix examples container
                        const examples = cardBack.querySelector('.resource-examples');
                        if (examples) {
                            examples.style.marginTop = '15px';
                            examples.style.display = 'flex';
                            examples.style.flexWrap = 'wrap';
                            examples.style.gap = '4px';
                            examples.style.justifyContent = 'center';
                            examples.style.width = '100%';
                        }
                    }
                    
                    // Special handling for reusable card
                    if (card.getAttribute('data-resource-type') === 'reusable') {
                        card.id = 'reusable-resource-card';
                        
                        // Force reset all transforms for the reusable card
                        card.style.transform = 'none';
                        card.style.perspective = 'none';
                        card.style.backfaceVisibility = 'visible';
                        
                        const cardInner = card.querySelector('.resource-card-inner');
                        if (cardInner) {
                            cardInner.style.transform = 'none';
                            cardInner.style.transformStyle = 'flat';
                        }
                        
                        const cardFront = card.querySelector('.resource-card-front');
                        const cardBack = card.querySelector('.resource-card-back');
                        
                        if (cardFront && cardBack) {
                            cardFront.style.position = 'absolute';
                            cardFront.style.backfaceVisibility = 'visible';
                            cardFront.style.transform = 'none';
                            
                            cardBack.style.position = 'absolute';
                            cardBack.style.backfaceVisibility = 'visible';
                            cardBack.style.transform = 'none';
                            cardBack.style.opacity = '0';
                        }
                        
                        // Fix particles placement for reusable card
                        const particles = card.querySelectorAll('.particle');
                        particles.forEach(particle => {
                            particle.style.position = 'absolute';
                            particle.style.top = '0';
                            particle.style.left = '0';
                            particle.style.width = '4px';
                            particle.style.height = '4px';
                            particle.style.opacity = '0.5';
                            particle.style.transform = 'none';
                            particle.style.animation = 'none';
                        });
                    }
                    
                    // Remove any existing click handlers that might cause issues
                    card.replaceWith(card.cloneNode(true));
                });
                
                // Get fresh references after cloning
                const updatedCards = document.querySelectorAll('.resource-3d-card');
                
                updatedCards.forEach(card => {
                    // Variables to track touch for determining scroll vs tap
                    let touchStartY = 0;
                    let touchStartX = 0;
                    let isTouchMove = false;
                    
                    // Create safer touch handlers that allow scrolling
                    card.addEventListener('touchstart', function(e) {
                        // Record the starting position for determining if this is a scroll
                        touchStartY = e.touches[0].clientY;
                        touchStartX = e.touches[0].clientX;
                        isTouchMove = false;
                        
                        // Don't prevent default on touchstart to allow scrolling
                    }, { passive: true });
                    
                    // Track touch movement to detect scrolling
                    card.addEventListener('touchmove', function(e) {
                        const touchY = e.touches[0].clientY;
                        const touchX = e.touches[0].clientX;
                        const deltaY = Math.abs(touchY - touchStartY);
                        const deltaX = Math.abs(touchX - touchStartX);
                        
                        // If vertical movement is greater than horizontal, it's likely a scroll
                        if (deltaY > deltaX && deltaY > 10) {
                            isTouchMove = true;
                        }
                        
                        // Don't prevent default to allow scrolling
                    }, { passive: true });
                    
                    card.addEventListener('touchend', function(e) {
                        // Only handle card flipping if this wasn't a scroll attempt
                        if (!isTouchMove) {
                            // Only prevent default for card flipping action, not for scrolling
                            e.preventDefault();
                            
                            // Debounce rapid taps
                            const now = Date.now();
                            if (lastTapped && now - lastTapped < 300) {
                                return;
                            }
                            lastTapped = now;
                            
                            // Toggle the flipped state
                            this.classList.toggle('flipped');
                            
                            // Special handling for the reusable card
                            if (this.getAttribute('data-resource-type') === 'reusable') {
                                const front = this.querySelector('.resource-card-front');
                                const back = this.querySelector('.resource-card-back');
                                
                                if (this.classList.contains('flipped')) {
                                    if (front) front.style.opacity = '0';
                                    if (back) back.style.opacity = '1';
                                } else {
                                    if (front) front.style.opacity = '1';
                                    if (back) back.style.opacity = '0';
                                }
                            }
                            
                            // Force layout recalculation to prevent shifts
                            window.requestAnimationFrame(() => {
                                document.body.style.height; // Force reflow
                            });
                        }
                    }, { passive: false });
                });
                
                // Fix the resource tags display
                const resourceTags = document.querySelectorAll('.resource-tag');
                resourceTags.forEach(tag => {
                    tag.style.display = 'inline-block';
                    tag.style.margin = '2px';
                    tag.style.padding = '3px 8px';
                    tag.style.borderRadius = '10px';
                    tag.style.fontSize = '0.7rem';
                });
                
                // Fix position of theme and contrast toggles to prevent shifting
                const themeToggle = document.getElementById('themeToggle');
                const contrastToggle = document.getElementById('contrastToggle');
                
                if (themeToggle) {
                    themeToggle.style.position = 'fixed';
                    themeToggle.style.transform = 'none';
                }
                
                if (contrastToggle) {
                    contrastToggle.style.position = 'fixed';
                    contrastToggle.style.transform = 'none';
                }
                
                // Prevent any zooming behavior on double tap, but allow scrolling
                let documentTouchStartY = 0;
                let documentIsTouchMove = false;
                
                document.addEventListener('touchstart', function(e) {
                    documentTouchStartY = e.touches[0].clientY;
                    documentIsTouchMove = false;
                }, { passive: true });
                
                document.addEventListener('touchmove', function(e) {
                    const touchY = e.touches[0].clientY;
                    const deltaY = Math.abs(touchY - documentTouchStartY);
                    
                    if (deltaY > 10) {
                        documentIsTouchMove = true;
                    }
                }, { passive: true });
                
                document.addEventListener('touchend', function(e) {
                    // Only prevent double-tap zoom if this wasn't a scroll attempt
                    if (!documentIsTouchMove) {
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastTapped;
                        if (tapLength < 500 && tapLength > 0) {
                            e.preventDefault();
                        }
                    }
                }, { passive: false });
            }
        }
    </script>
    
    <!-- Failsafe script to ensure tutorial step numbers and buttons are visible -->
    <script>
        window.addEventListener('load', function() {
            // Failsafe function to ensure tutorial elements are always visible
            function ensureVisibility() {
                // Fix step numbers with explicit styling
                document.querySelectorAll('.tutorial-step-number').forEach(step => {
                    step.setAttribute('style', 'background: linear-gradient(135deg, #3b82f6, #2563eb) !important; color: #ffffff !important; border: none !important; font-weight: bold !important; box-shadow: 0 4px 10px rgba(59, 130, 246, 0.5) !important; display: flex !important; align-items: center !important; justify-content: center !important;');
                });
                
                // Fix try simulator button with explicit styling
                const simulatorBtn = document.querySelector('.try-simulator-btn');
                if (simulatorBtn) {
                    simulatorBtn.setAttribute('style', 'background: linear-gradient(to right, #3b82f6, #2563eb) !important; color: #ffffff !important; border: none !important; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.25) !important; font-weight: bold !important; display: inline-flex !important;');
                    
                    // Make sure the SVG inside the button is also white
                    const svgIcon = simulatorBtn.querySelector('svg');
                    if (svgIcon) {
                        svgIcon.setAttribute('style', 'fill: #ffffff !important;');
                    }
                }
                
                // Fix Simulate Allocation button
                const allocateBtn = document.querySelector('.allocate-btn');
                if (allocateBtn) {
                    // Apply high contrast styling based on theme
                    const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                    const isLightTheme = document.documentElement.getAttribute('data-theme') !== 'dark';
                    
                    if (isHighContrast) {
                        if (isLightTheme) {
                            allocateBtn.setAttribute('style', 'background: #000000 !important; color: #ffffff !important; border: 2px solid #ffffff !important;');
                        } else {
                            allocateBtn.setAttribute('style', 'background: #ffffff !important; color: #000000 !important; border: 2px solid #000000 !important;');
                        }
                    } else {
                        allocateBtn.setAttribute('style', 'background: linear-gradient(135deg, #4f46e5, #818cf8) !important; color: #ffffff !important; border: none !important;');
                    }
                }
                
                // Fix "Master the Simulator" title in high contrast mode
                const tutorialTitle = document.querySelector('h2.tutorial-glow');
                if (tutorialTitle) {
                    const isHighContrast = document.documentElement.getAttribute('data-contrast') === 'high';
                    const isLightTheme = document.documentElement.getAttribute('data-theme') !== 'dark';
                    
                    if (isHighContrast) {
                        if (isLightTheme) {
                            tutorialTitle.setAttribute('style', 'background-color: transparent !important; color: black !important; text-shadow: none !important; border: none !important; box-shadow: none !important; padding: 0 !important; border-radius: 0 !important;');
                        } else {
                            tutorialTitle.setAttribute('style', 'background-color: transparent !important; color: white !important; text-shadow: none !important; border: none !important; box-shadow: none !important; padding: 0 !important; border-radius: 0 !important;');
                        }
                    } else {
                        tutorialTitle.setAttribute('style', 'background-color: transparent !important; color: var(--text-primary) !important; text-shadow: 0 0 15px rgba(var(--primary-rgb), 0.3) !important; border: none !important; box-shadow: none !important; padding: 0 !important; border-radius: 0 !important;');
                    }
                }
            }
            
            // Run immediately and again after a short delay to override any other scripts
            ensureVisibility();
            // Only run one more time after all content has settled
            setTimeout(ensureVisibility, 1000);
        });
    </script>
    
    <!-- Failsafe script to fix toggle buttons on mobile -->
    <script>
        window.addEventListener('load', function() {
            // Fix toggle buttons positioning for mobile view
            function fixToggleButtons() {
                const themeToggle = document.getElementById('themeToggle');
                const contrastToggle = document.getElementById('contrastToggle');
                
                if (window.innerWidth <= 768) {
                    // Position at bottom of screen for mobile
                    if (themeToggle) {
                        themeToggle.style.position = 'fixed';
                        themeToggle.style.top = 'auto';
                        themeToggle.style.bottom = '20px';
                        themeToggle.style.right = '20px';
                        themeToggle.style.zIndex = '9999';
                    }
                    
                    if (contrastToggle) {
                        contrastToggle.style.position = 'fixed';
                        contrastToggle.style.top = 'auto';
                        contrastToggle.style.bottom = '20px';
                        contrastToggle.style.right = '70px';
                        contrastToggle.style.zIndex = '9999';
                    }
                    
                    // Add padding to prevent content from being hidden under buttons
                    document.body.style.paddingBottom = '70px';
                }
            }
            
            // Run immediately and on resize
            fixToggleButtons();
            window.addEventListener('resize', fixToggleButtons);
            
            // Also run after a short delay to ensure it applies after all other scripts
            setTimeout(fixToggleButtons, 500);
        });
    </script>
    
    <!-- Failsafe for device detection and toggle positioning -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Detect touch device
            function isTouchDevice() {
                return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
            }
            
            // Mark as touch device if needed
            if (isTouchDevice()) {
                document.body.setAttribute('data-touch', 'true');
                document.body.classList.add('mobile-device');
                
                // Update hint text for mobile
                const hintElements = document.querySelectorAll('.hover-hint, [data-hint]');
                hintElements.forEach(el => {
                    if (el.textContent.includes('hover')) {
                        el.textContent = el.textContent.replace('hover', 'tap');
                    }
                    
                    // Also update data-hint attribute if present
                    if (el.hasAttribute('data-hint')) {
                        el.setAttribute('data-hint', el.getAttribute('data-hint').replace('hover', 'tap'));
                    }
                });
                
                // Ensure toggles are correctly positioned
                const themeToggle = document.querySelector('.theme-toggle');
                const contrastToggle = document.querySelector('.contrast-toggle');
                
                if (themeToggle) {
                    themeToggle.style.position = 'fixed';
                    themeToggle.style.bottom = '20px';
                    themeToggle.style.right = '20px';
                    themeToggle.style.top = 'auto';
                    themeToggle.style.zIndex = '1000';
                }
                
                if (contrastToggle) {
                    contrastToggle.style.position = 'fixed';
                    contrastToggle.style.bottom = '20px';
                    contrastToggle.style.right = '70px';
                    contrastToggle.style.top = 'auto';
                    contrastToggle.style.zIndex = '1000';
                }
            }
        });
    </script>
</body>
</html> 
